---
title: "Cluster Assignment and Stratified Covariate Constrained Randomization for Spatially-Correlated Data: Euclidean Distances"
author: "Patrick Iben"
date: "January 26, 2020"
output: html_document
---

This document provides a method on selecting clusters and treatment assignments for stratified cluster randomized trials, via covariate-constrained randomization and from spatially-correlated data. Three clustering techniques are used: K-Means; Clustering Large Applications (CLARA); Ward Hierarchical Clustering. The distance metric is Euclidean distance. 

```{r, echo=F, message=F, warning=F}
op <- par()
options(width=80)
emptyenv()
rm(list=ls())

### MAPPING PACKAGES ###
packages <- c("RColorBrewer", "sp", "maptools", "lattice", "latticeExtra", "rgdal", "classInt", "gridExtra","ggplot2","tidyr","zeallot", "cluster", "ClustGeo", "WeightedCluster", "cvcrand", "spdep", "foreign", "spatstat", "gmodels","tidyverse", "amap")
#install.packages(packages)
lapply(packages, library, character.only = TRUE)
#load base tools() package
library(tools)

#Setting working directory for village-level spatial feature data
choose.dir()

#Reading in village data
vill <- read.csv('study_by_village.csv')
vill2 <- vill[c(1:10, 21, 22)]

#Fixing village names with toTitleCase() function from the "tools" package
vill2$village_name <- toTitleCase(as.character(vill2$village_name))

#Reading in Magoro and Toroma village names
vnames <- read.csv('villageNames.csv')

#Merging in and formatting village, subcounty names
tab3 <- merge(vill2, vnames, by.x = c("subcounty", "village"),
              by.y = c("repcty", "village.2"), all.x = T)
tab3$village_name.y <- as.character(tab3$village_name.y)

tab3$village_name <- tab3$village_name.x
tab3$village_name <- ifelse(is.na(tab3$village_name)==T, tab3$village_name.y, tab3$village_name)
tab3$village_name <- toTitleCase(tolower(tab3$village_name))

#Removing duplicate codes
lim <- subset(tab3, duplicated(village_code) == F)

#Creating identifier that combines village and subcounty
lim$village_code <- paste(lim$village, lim$subcounty, sep="_")

#Getting household information, by village
hh <- read.csv('hhPerVillage.csv')
hh$village_code <- paste(hh$village, hh$county, sep="_")

#Nulling out extraneous village and county names
hh$village <- NULL
hh$county <- NULL

#Merging household and village data by village and subcounty
lim2 <- merge(lim, hh, by="village_code", all.x=T)

#Creating derived variable for household density
lim2$hhDensity <- lim2$hh/lim2$areakm2

#Reading in survey-level data, surveys 1 to 4
vstat <- read.csv('surveyResultsByVillage.csv')
vstat$X <- NULL

#Reading in most recent survey-level data
s5 <- read.csv('s5data.csv')
s5lim <- subset(s5, Scounty != 2)
s5lim$survey <- 5

#Reading in survey 5 microscopy data
s5micro <- read.csv("s5micros.csv")
s5micro$survey <- 5

#Removing county serving as control group
s5microlim <- subset(s5micro, Scounty != 2)

#Cleaning up microscopy variable names
colnames(s5microlim)[colnames(s5microlim)=="microsPos"] <- "microPos"
colnames(s5microlim)[colnames(s5microlim)=="microsTests"] <- "microTests"

#Merging microscopy data into the rest of the survey 5 data
s5lim <- merge(s5lim, s5microlim, by.x=c("Scounty", "Village", "survey"), 
              by.y=c("Scounty", "Village", "survey"), all = T)

a1 <- merge(vstat, s5lim, by.x=c("county", "village", "survey", "rdtPos", "rdtTests", "microPos", "microTests"), 
              by.y=c("Scounty", "Village", "survey", "rdtPos", "rdtTests", "microPos", "microTests"), all = T)

#Merging into final collection of all study data
all <- merge(a1, lim2, by.x = c("county", "village"), by.y = c("subcounty", "village"))
#Nulling out old village names
all$village_name.x <- NULL
all$village_name.y <- NULL
#Calculating prevalence rates
all$mrate <- all$microPos/all$microTests
all$rrate <- all$rdtPos/all$rdtTests

#Ensuring that single-digit village codes have leading 0
all$village_code <- ifelse(nchar(all$village_code)<4, paste(0,all$village_code, sep = ""),all$village_code)

#Adding indicator for bordering lake or wetlands
all$BordersWater <- ifelse(all$village_code %in% c('01_1', '02_1', '03_1', '04_1', '05_1', '06_1', '07_1', '08_1', '10_1', '12_1', '14_1', '16_1', '17_1', '18_1', '07_3', '08_3', '12_3', '14_3', '17_3', '19_3', '20_3', '25_3', '28_3', '29_3', '32_3', '36_3'),1,0)

#Generically renaming for ease of interpretation
study_data <- all

#Ensuring sorted by hierarchy of data
study_data<- study_data[with(study_data, order(county, village, survey)), ] 

#Transposing long to wide
study_data_wide <- reshape(study_data, idvar = "village_code", sep = "_", timevar = "survey", v.names = c("rdtTests","rdtPos","rrate", "microPos", "microTests", "mrate"),direction = "wide")

#Spatially plotting covariates

#Read in the shape file for villages
poly1 <- readShapePoly("pilgrim_africa_villages_shapefile/pilgrim_villages.shp")

#Checking village names in shapefile
#poly1@data
#Creating subset without control group
poly1_noMagoro <- poly1[c(1:55),]

#Comparing and matching row names for merging
#row.names(poly1_noMagoro)
row.names(poly1_noMagoro@data) <-poly1_noMagoro@data$village_sc
row.names(poly1_noMagoro) <- row.names(poly1_noMagoro@data)
#row.names(study_data_wide)
rownames(study_data_wide) <- study_data_wide$village_code

#Building spatial polygons dataframe from shape file and feature data
map <- SpatialPolygonsDataFrame(poly1_noMagoro, study_data_wide)

#Assigning village codes to row names
rownames(map@data) <- map$village_code

#Adding color palette schemes using brewer.pal() funtion from 'RColorBrewer' package
tempPal <- brewer.pal(n = 6, name = "YlOrRd")#N color scheme
waterPal <- brewer.pal(n = 9, name = "YlGnBu")#water color scheme

#Extracting spatial location coordinates
geo_data <- coordinates(poly1_noMagoro)
```

As CRTs tend to have only two treatment arms for which to randomize clusters (treatment and control), only even number of clusters can be considered to evenly assign units. For this example, the one stratification variable - subcounty - has two levels. Thus, to best assure even allocation of the two trial arms into the two strata levels (though not a guarantee), only cluster sizes divisible by four should be considered. If only four clusters are created, then there are a total of six (4 choose 2) configurations to select randomly from for CCR. 

If the default cutoff for cvrall() of 10% is used, then this leaves only one treatment allocation scheme to select from, thus creating a deterministic selection for cluster assignment - and no longer qualifies as a randomized control trial. To remove this possibility, only multiples of four, that are greater than or equal to eight, are considered. 

```{r, echo=T, message=F, warning=F}
#Setting minimum K for cluster size -
minclust <- 8 
#Setting maximum K for cluster size to ensure at least 3 units per cluster for buffer
n_3 <- round((nrow(study_data_wide))/3)
n_3_even <- ifelse(n_3 %% 2 != 0, n_3-1, n_3)#If odd, subtract 1
n_3_divby4 <- ifelse(n_3_even %% 4 != 0, n_3_even-2, n_3_even)#If not divisible by 4, subtract 2

#If ((closest even number under number of units divided by 3) *3)) is greater than number of units, then subtract 4 from previous line for the maximum cluster size
maxclust <- ifelse((n_3_divby4*3) > nrow(study_data_wide), n_3_divby4-4, n_3_divby4)

paste("For this example, a maximum of ", maxclust, " clusters will be tested", sep="")
```

####CCR Weights

"cvcrand" allows for custom weighting of covariate importance while performing CCR. For this example, we use standardized regression coefficients from a Poisson cell-means model with an offset via the glm() function. We are using standardized village-level data (due to the sparsity of cluster-level data); to standardize the data, the scale() function is used. The regression coefficients are standardized such that their absolute values sum to 1 - the relative weight of a given covariate is defined as the absolute value of its model coefficient divided by the sum of the absolute values of all model coefficients. To keep consistent with package author guidelines of weights greater than 1, each weight is then multiplied by 100.

```{r, echo=T, message=F, warning=F}
#Scaling covariates (not outcome or offset)
study_data_wide$scaled_microPos_1 <- scale(study_data_wide$microPos_1)
study_data_wide$scaled_BordersWater <- scale(study_data_wide$BordersWater)
study_data_wide$scaled_hhDensity <- scale(study_data_wide$hhDensity)

#Creating Poisson model with offset
weight_model <- glm(microPos_5 ~ scaled_microPos_1 + scaled_BordersWater + scaled_hhDensity+ offset(log(microTests_5)) -1, 
                 data=study_data_wide, family = poisson)
summary(weight_model)

#Scaling and saving model coefficients for CCR weights
weights_raw <- c(abs(weight_model$coefficients[1][[1]])/sum(abs(weight_model$coefficients)), abs(weight_model$coefficients[2][[1]])/sum(abs(weight_model$coefficients)), abs(weight_model$coefficients[3][[1]])/sum(abs(weight_model$coefficients)))

#Saving scaled weights
weights <- weights_raw * 100

#Subsetting variables of interest for cluster-level summary stats
CCR_covariates <- study_data_wide[,c("microPos_1", "microTests_1", "BordersWater", "hh", "areakm2", "county")]

#Naming cluster summary statistics for CCR
#For this data scenario, the overall cluster-level summary statistics are: baseline microscopy rate, household density, and proportion of cluster bordering water.
Cluster_SumStats <- c("Cluster_mRate_1", "Cluster_hhDensity", "Cluster_prop_BordersWater") 
#Naming strata
Strata <- "county"
#Merging names
CCR_SumStats_Strata <- c(Cluster_SumStats, Strata)
```

####CCR Optimization

```{r, echo=T, message=F, warning=F}
kmeans_best_ccr<-NA
seed <- 1
while (is.na(kmeans_best_ccr)){

#Initializing listing of cluster assignments for each value of K
clustering_list <- list()

#Collecting cluster quality statistics across range of cluster sizes
for(i in seq(minclust,maxclust, by = 4)){
  set.seed(seed)
  clustering_list[[i-(minclust-1)]] <- kmeans(geo_data, i)$cluster
}

#Stripping null list elements
clustering_list[sapply(clustering_list, is.null)] <- NULL

#Adding labels
names(clustering_list) <- seq(minclust,maxclust, by= 4)

#Converting from list to matrix
#Initializing
kmeans_cluster_assignments <- matrix(data = NA, nrow = nrow(geo_data), ncol = length(clustering_list), byrow = FALSE,dimnames = NULL)

for(i in 1:length(clustering_list)){
  kmeans_cluster_assignments[,i] <- clustering_list[[i]]
  colnames(kmeans_cluster_assignments) <- cat("kmeans_",max(kmeans_cluster_assignments[,i]), sep = "")
}

colnames(kmeans_cluster_assignments) <- paste("kmeans_", seq(minclust,maxclust, by= 4), sep = "")
rownames(kmeans_cluster_assignments) <- names(clustering_list[[1]])

#Merging into main dataframe
study_data_wide <- merge(kmeans_cluster_assignments, study_data_wide,by = "row.names")

study_data_wide$Row.names <- NULL

#K-Means CCR

#Adding in village code to merge with lat/long. (for spatial clustering test)
village_code <- rownames(kmeans_cluster_assignments)
kmeans_cluster_assignments_df <- data.frame(cbind(kmeans_cluster_assignments, village_code))

#Saving spatial location as df for merging
geo_data_df <- data.frame(geo_data)
colnames(geo_data_df) <- c("village_long", "village_lat")
geo_data_df$village_code <- rownames(geo_data_df)

#Initializing listing of cluster assignments for each value of K
kmeans_sumstats <- list()
kmeans_ccr <-list()
kmeans_spat_clust <- list()
trt_loc <- list()
split_trt_loc <- list()
spat_clust <- matrix(data = NA, nrow = ncol(kmeans_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)
ccr_selected <- matrix(data = NA, nrow = ncol(kmeans_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)
balanced_strata <- matrix(data = NA, nrow = ncol(kmeans_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)

#Saving cluster summary statistics for balancing
for(i in 1:ncol(kmeans_cluster_assignments)){  
kmeans_sumstats[[i]] <- data.frame(cbind(kmeans_cluster_assignments[,i],CCR_covariates))

kmeans_sumstats[[i]][,"Cluster_mRate_1"] <- with(kmeans_sumstats[[i]], ave(microPos_1, kmeans_sumstats[[i]][,1], FUN=sum)) / with(kmeans_sumstats[[i]], ave(microTests_1, kmeans_sumstats[[i]][,1], FUN=sum))

kmeans_sumstats[[i]][,"Cluster_hhDensity"] <- with(kmeans_sumstats[[i]], ave(hh, kmeans_sumstats[[i]][,1], FUN=sum)) / with(kmeans_sumstats[[i]], ave(areakm2, kmeans_sumstats[[i]][,1], FUN=sum))

kmeans_sumstats[[i]][,"Cluster_prop_BordersWater"] <- with(kmeans_sumstats[[i]], ave(as.numeric(BordersWater), kmeans_sumstats[[i]][,1], FUN=sum)) / with(kmeans_sumstats[[i]], ave(as.numeric(BordersWater), kmeans_sumstats[[i]][,1], FUN=length))

#Ensuring sorted by clustering
kmeans_sumstats[[i]] <- kmeans_sumstats[[i]][order(kmeans_sumstats[[i]][,1]),]

#Outputting one row per subgroup summary stats
kmeans_sumstats[[i]] <- kmeans_sumstats[[i]][!duplicated(kmeans_sumstats[[i]][,1]),]

#CCR
kmeans_ccr[[i]] <- cvrall(clustername = kmeans_sumstats[[i]][,1],
                  balancemetric = "l2",
                  x = data.frame(kmeans_sumstats[[i]][ ,CCR_SumStats_Strata]),
                  ntotal_cluster = length(kmeans_sumstats[[i]][,1]),
                  ntrt_cluster = length(kmeans_sumstats[[i]][,1])/2,
                  weights = c(weights, 1000),
                  categorical = Strata,
                  cutoff = 0.1,
                  size = 25000000,
                  bhist = F,
                  seed = seed)

#Labeling treatment assignments
names(kmeans_ccr[[i]]$allocation) <- c(paste("kmeans_", length(kmeans_sumstats[[i]][,1]), sep = ""), paste("kmeans_", length(kmeans_sumstats[[i]][,1]), "_trt", sep = ""))

kmeans_cluster_assignments_df <- merge(kmeans_cluster_assignments_df, kmeans_ccr[[i]]$allocation)
kmeans_cluster_assignments_df$village_code <- as.character(kmeans_cluster_assignments_df$village_code)

#Merging with left_join() to keep row order
kmeans_cluster_assignments_df <- left_join(geo_data_df, kmeans_cluster_assignments_df)

#Saving separate dataframes of treatment assignments with their spatial location data (coordinates)
trt_loc[[i]] <- data.frame(cbind(select(kmeans_cluster_assignments_df, ends_with("_trt"))[i]), geo_data_df)

#Split by treatment group
split_trt_loc[[i]] <- split(trt_loc[[i]], trt_loc[[i]][1])

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
spat_clust[i,] <- ifelse(t.test(nndist(split_trt_loc[[i]]$`0`$village_lat, split_trt_loc[[i]]$`0`$village_long), nndist(split_trt_loc[[i]]$`1`$village_lat, split_trt_loc[[i]]$`1`$village_long))$p.value < 0.05, 1, 0)

#Testing for balance on strata
balanced_strata[i,] <- ifelse(regmatches(levels(kmeans_ccr[[i]]$baseline_table$`arm = 0`[5])[1], gregexpr("(?<=\\().*?(?=\\))", levels(kmeans_ccr[[i]]$baseline_table$`arm = 0`[5])[1], perl=T))[[1]] == "50.0" && regmatches(levels(kmeans_ccr[[i]]$baseline_table$`arm = 1`[5])[1], gregexpr("(?<=\\().*?(?=\\))", levels(kmeans_ccr[[i]]$baseline_table$`arm = 1`[5])[1], perl=T))[[1]] == "50.0"
,1,0)

#Saving selected ccr scores
ccr_selected[i,] <- as.numeric(kmeans_ccr[[i]]$bscores[1,2])
}

#Combining selected scores, whether or not there is evidence of spatial 
#heterogeneity, and whether or not strata are balanced
ccr_all <- data.frame(ccr_selected,spat_clust,balanced_strata)

#Selecting schemes that are balanced on strata and exhibit spatial heterogeneity
ccr_bal_clust <- ccr_all[which(ccr_all$spat_clust == 1 & ccr_all$balanced_strata == 1),]

#IDing lowest selected score
lowest_index <- as.numeric(rownames(ccr_bal_clust[which.min(ccr_bal_clust[,1]),]))
kmeans_best_ccr <- ifelse(length(lowest_index) == 0, NA, kmeans_ccr[lowest_index])
seed = seed + 1
}

paste("Seed: ",seed,sep = "")

seed_kmeans <- seed
seed_mat <- data.matrix(seed_kmeans)
colnames(seed_mat) <- "Seed"

#Isolating clustername and treatment arm
kmeans_ccr_mat <- cbind(kmeans_best_ccr[[1]]$allocation[1], kmeans_best_ccr[[1]]$allocation[2])
colnames(kmeans_ccr_mat) <- c("kmeans_cluster", "kmeans_treatment_arm")

#Saving best configuration
kmeans_optimized_treatments <- as.matrix(kmeans_cluster_assignments[,lowest_index])
kmeans_optimized_treatments <- cbind(kmeans_optimized_treatments,rownames(kmeans_optimized_treatments))
colnames(kmeans_optimized_treatments) <- c("kmeans_cluster", "village_code")

kmeans_optimized_treatments <- merge(kmeans_optimized_treatments, kmeans_ccr_mat, by = "kmeans_cluster")

K_kmeans <- max(as.numeric(kmeans_optimized_treatments$kmeans_cluster))

#Adding treatment allocations to clusters for proper labeling with spplot()
#Cluster assignments
kmeans_clustering <- as.matrix(kmeans_cluster_assignments[,lowest_index])
colnames(kmeans_clustering) <- "kmeans_cluster"
#Adding village codes as a variable for linking
kmeans_names <- as.matrix(rownames(kmeans_clustering))
colnames(kmeans_names) <- "village_code"
kmeans_clustering <- as.matrix(cbind(kmeans_clustering,kmeans_names))

#Treatment assignments
kmeans_treatments <- as.matrix(kmeans_optimized_treatments$kmeans_treatment_arm)
rownames(kmeans_treatments) <- kmeans_optimized_treatments$village_code
colnames(kmeans_treatments) <- "Treatment_Group"

kmeans_trtnames <- as.matrix(rownames(kmeans_treatments))
colnames(kmeans_trtnames) <- "village_code"

kmeans_treatments <- cbind(kmeans_treatments,kmeans_trtnames)

#Saving as DFs for merging
kmeans_clustering_df <- data.frame(kmeans_clustering)
kmeans_treatments_df <- data.frame(kmeans_treatments)

#Maintaining order of village codes with left_join from dplyr 
kmeans_df <- left_join(kmeans_clustering_df, kmeans_treatments_df, by ="village_code")

#Saving as matrix for spatial plots
kmeans_treatments <- as.matrix(kmeans_df[,2:3])

#Labeling
village_code <- rownames(geo_data)
colnames(geo_data) <- c("village_long", "village_lat")
#Merging location with unit label
village_coords <- data.frame(cbind(geo_data, village_code))

#Merging centroids with optimized treatment assignments
kmeans_best_df <- left_join(kmeans_df, village_coords, by ="village_code")
#Merging with seed that was ultimately used for configuration
kmeans_best_df <- data.frame(kmeans_best_df, seed_mat)

####CLARA

clara_best_ccr<-NA
seed <- 1
while (is.na(clara_best_ccr)){
#Initializing listing of cluster assignments for each value of K
clustering_list <- list()

#Collecting cluster quality statistics across range of cluster sizes
for(i in seq(minclust,maxclust, by = 4)){
  clustering_list[[i-(minclust-1)]] <- clara(geo_data, metric = "euclidean", k = i)$cluster
}

#Stripping null list elements
clustering_list[sapply(clustering_list, is.null)] <- NULL

#Adding labels
names(clustering_list) <- seq(minclust,maxclust, by= 4)

#Converting from list to matrix
#Initializing
clara_cluster_assignments <- matrix(data = NA, nrow = nrow(geo_data), ncol = length(clustering_list), byrow = FALSE,dimnames = NULL)

for(i in 1:length(clustering_list)){
  clara_cluster_assignments[,i] <- clustering_list[[i]]
  colnames(clara_cluster_assignments) <- cat("clara_",max(clara_cluster_assignments[,i]), sep = "")
}

colnames(clara_cluster_assignments) <- paste("clara_", seq(minclust,maxclust, by= 4), sep = "")
rownames(clara_cluster_assignments) <- names(clustering_list[[1]])

#Merging into main dataframe
study_data_wide <- merge(clara_cluster_assignments, study_data_wide,by = "row.names")

study_data_wide$Row.names <- NULL

#CLARA CCR

#Adding in village code to merge with lat/long. (for spatial clustering test)
village_code <- rownames(clara_cluster_assignments)
clara_cluster_assignments_df <- data.frame(cbind(clara_cluster_assignments, village_code))

#Saving spatial location as df for merging
geo_data_df <- data.frame(geo_data)
colnames(geo_data_df) <- c("village_long", "village_lat")
geo_data_df$village_code <- rownames(geo_data_df)

#Initializing listing of cluster assignments for each value of K
clara_sumstats <- list()
clara_ccr <-list()
clara_spat_clust <- list()
trt_loc <- list()
split_trt_loc <- list()
spat_clust <- matrix(data = NA, nrow = ncol(clara_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)
ccr_selected <- matrix(data = NA, nrow = ncol(clara_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)
balanced_strata <- matrix(data = NA, nrow = ncol(clara_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)

#Saving cluster summary statistics for balancing
for(i in 1:ncol(clara_cluster_assignments)){  
clara_sumstats[[i]] <- data.frame(cbind(clara_cluster_assignments[,i],CCR_covariates))

clara_sumstats[[i]][,"Cluster_mRate_1"] <- with(clara_sumstats[[i]], ave(microPos_1, clara_sumstats[[i]][,1], FUN=sum)) / with(clara_sumstats[[i]], ave(microTests_1, clara_sumstats[[i]][,1], FUN=sum))

clara_sumstats[[i]][,"Cluster_hhDensity"] <- with(clara_sumstats[[i]], ave(hh, clara_sumstats[[i]][,1], FUN=sum)) / with(clara_sumstats[[i]], ave(areakm2, clara_sumstats[[i]][,1], FUN=sum))

clara_sumstats[[i]][,"Cluster_prop_BordersWater"] <- with(clara_sumstats[[i]], ave(as.numeric(BordersWater), clara_sumstats[[i]][,1], FUN=sum)) / with(clara_sumstats[[i]], ave(as.numeric(BordersWater), clara_sumstats[[i]][,1], FUN=length))

#Ensuring sorted by clustering
clara_sumstats[[i]] <- clara_sumstats[[i]][order(clara_sumstats[[i]][,1]),]

#Outputting one row per subgroup summary stats
clara_sumstats[[i]] <- clara_sumstats[[i]][!duplicated(clara_sumstats[[i]][,1]),]

#CCR
clara_ccr[[i]] <- cvrall(clustername = clara_sumstats[[i]][,1],
                  balancemetric = "l2",
                  x = data.frame(clara_sumstats[[i]][ ,CCR_SumStats_Strata]),
                  ntotal_cluster = length(clara_sumstats[[i]][,1]),
                  ntrt_cluster = length(clara_sumstats[[i]][,1])/2,
                  weights = c(weights, 1000),
                  categorical = Strata,
                  cutoff = 0.1,
                  size = 25000000,
                  bhist = F,
                  seed = seed)

#Labeling treatment assignments
names(clara_ccr[[i]]$allocation) <- c(paste("clara_", length(clara_sumstats[[i]][,1]), sep = ""), paste("clara_", length(clara_sumstats[[i]][,1]), "_trt", sep = ""))

clara_cluster_assignments_df <- merge(clara_cluster_assignments_df, clara_ccr[[i]]$allocation)
clara_cluster_assignments_df$village_code <- as.character(clara_cluster_assignments_df$village_code)

#Merging with left_join() to keep row order
clara_cluster_assignments_df <- left_join(geo_data_df, clara_cluster_assignments_df)

#Saving separate dataframes of treatment assignments with their spatial location data (coordinates)
trt_loc[[i]] <- data.frame(cbind(select(clara_cluster_assignments_df, ends_with("_trt"))[i]), geo_data_df)

#Split by treatment group
split_trt_loc[[i]] <- split(trt_loc[[i]], trt_loc[[i]][1])

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
spat_clust[i,] <- ifelse(t.test(nndist(split_trt_loc[[i]]$`0`$village_lat, split_trt_loc[[i]]$`0`$village_long), nndist(split_trt_loc[[i]]$`1`$village_lat, split_trt_loc[[i]]$`1`$village_long))$p.value < 0.05, 1, 0)

#Testing for balance on strata
balanced_strata[i,] <- ifelse(regmatches(levels(clara_ccr[[i]]$baseline_table$`arm = 0`[5])[1], gregexpr("(?<=\\().*?(?=\\))", levels(clara_ccr[[i]]$baseline_table$`arm = 0`[5])[1], perl=T))[[1]] == "50.0" && regmatches(levels(clara_ccr[[i]]$baseline_table$`arm = 1`[5])[1], gregexpr("(?<=\\().*?(?=\\))", levels(clara_ccr[[i]]$baseline_table$`arm = 1`[5])[1], perl=T))[[1]] == "50.0"
,1,0)

#Saving selected ccr scores
ccr_selected[i,] <- as.numeric(clara_ccr[[i]]$bscores[1,2])
}

#Combining selected scores, whether or not there is evidence of spatial 
#heterogeneity, and whether or not strata are balanced
ccr_all <- data.frame(ccr_selected,spat_clust,balanced_strata)

#Selecting schemes that are balanced on strata and exhibit spatial heterogeneity
ccr_bal_clust <- ccr_all[which(ccr_all$spat_clust == 1 & ccr_all$balanced_strata == 1),]

#IDing lowest selected score
lowest_index <- as.numeric(rownames(ccr_bal_clust[which.min(ccr_bal_clust[,1]),]))
clara_best_ccr <- ifelse(length(lowest_index) == 0, NA, clara_ccr[lowest_index])

seed = seed + 1 
}

paste("Seed: ",seed,sep = "")

#Saving seed
seed_clara <- seed
seed_mat <- data.matrix(seed_clara)
colnames(seed_mat) <- "Seed"

#Isolating clustername and treatment arm
clara_ccr_mat <- cbind(clara_best_ccr[[1]]$allocation[1], clara_best_ccr[[1]]$allocation[2])
colnames(clara_ccr_mat) <- c("clara_cluster", "clara_treatment_arm")

#Saving best configuration
clara_optimized_treatments <- as.matrix(clara_cluster_assignments[,lowest_index])
clara_optimized_treatments <- cbind(clara_optimized_treatments,rownames(clara_optimized_treatments))
colnames(clara_optimized_treatments) <- c("clara_cluster", "village_code")

clara_optimized_treatments <- merge(clara_optimized_treatments, clara_ccr_mat, by = "clara_cluster")

K_clara <- max(as.numeric(clara_optimized_treatments$clara_cluster))

#Adding treatment allocations to clusters for proper labeling with spplot()
#Cluster assignments
clara_clustering <- as.matrix(clara_cluster_assignments[,lowest_index])
colnames(clara_clustering) <- "clara_cluster"
#Adding village codes as a variable for linking
clara_names <- as.matrix(rownames(clara_clustering))
colnames(clara_names) <- "village_code"
clara_clustering <- as.matrix(cbind(clara_clustering,clara_names))

#Treatment assignments
clara_treatments <- as.matrix(clara_optimized_treatments$clara_treatment_arm)
rownames(clara_treatments) <- clara_optimized_treatments$village_code
colnames(clara_treatments) <- "Treatment_Group"

clara_trtnames <- as.matrix(rownames(clara_treatments))
colnames(clara_trtnames) <- "village_code"

clara_treatments <- cbind(clara_treatments,clara_trtnames)

#Saving as DFs for merging
clara_clustering_df <- data.frame(clara_clustering)
clara_treatments_df <- data.frame(clara_treatments)

#Maintaining order of village codes with left_join from dplyr 
clara_df <- left_join(clara_clustering_df, clara_treatments_df, by ="village_code")

#Saving as matrix for spatial plots
clara_treatments <- as.matrix(clara_df[,2:3])

#Labeling
village_code <- rownames(geo_data)
colnames(geo_data) <- c("village_long", "village_lat")
#Merging location with unit label
village_coords <- data.frame(cbind(geo_data, village_code))

#Merging centroids with optimized treatment assignments
clara_best_df <- left_join(clara_df, village_coords, by ="village_code")
#Merging df with ultimate seed
clara_best_df <- data.frame(clara_best_df, seed_clara)

##Ward Hierarchical Clustering

hclust_best_ccr<-NA
seed <- 1
while (is.na(hclust_best_ccr)){
#Initializing listing of cluster assignments for each value of K
clustering_list <- list()
hclust_cluster_assignments <- matrix(data = NA, nrow = nrow(geo_data), ncol = maxclust-minclust+1, byrow = FALSE,dimnames = NULL)
colnames(hclust_cluster_assignments) <- minclust:maxclust

#Geographical distance
dist <- as.dist(as.matrix(daisy(geo_data, metric = "euclidean")))

#Performing hierarchical clustering with Ward.D metric
tree <- hclust(dist, "ward.D")

#Collecting cluster quality statistic across range of cluster sizes
for(i in seq(minclust,maxclust, by = 4)){
  clustering_list[[i-(minclust-1)]] <- cutree(tree,i)#Making K cuts
} 

#Stripping null list elements
clustering_list[sapply(clustering_list, is.null)] <- NULL

#Adding labels
names(clustering_list) <- seq(minclust,maxclust, by= 4)

#Converting from list to matrix
#Initializing
hclust_cluster_assignments <- matrix(data = NA, nrow = nrow(geo_data), ncol = length(clustering_list), byrow = FALSE,dimnames = NULL)

for(i in 1:length(clustering_list)){
  hclust_cluster_assignments[,i] <- clustering_list[[i]]
}

colnames(hclust_cluster_assignments) <- paste("hclust_", seq(minclust,maxclust, by= 4), sep = "")
rownames(hclust_cluster_assignments) <- names(clustering_list[[1]])

#Merging into main dataframe
study_data_wide <- merge(hclust_cluster_assignments, study_data_wide,by = "row.names")

study_data_wide$Row.names <- NULL

#Adding in village code to merge with lat/long. (for spatial clustering test)
village_code <- rownames(hclust_cluster_assignments)
hclust_cluster_assignments_df <- data.frame(cbind(hclust_cluster_assignments, village_code))

#Saving spatial location as df for merging
geo_data_df <- data.frame(geo_data)
colnames(geo_data_df) <- c("village_long", "village_lat")
geo_data_df$village_code <- rownames(geo_data_df)

#H-Clust CCR

#Initializing listing of cluster assignments for each value of K
hclust_sumstats <- list()
hclust_ccr <-list()
hclust_spat_clust <- list()
trt_loc <- list()
split_trt_loc <- list()
spat_clust <- matrix(data = NA, nrow = ncol(hclust_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)
ccr_selected <- matrix(data = NA, nrow = ncol(hclust_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)
balanced_strata <- matrix(data = NA, nrow = ncol(hclust_cluster_assignments), ncol = 1, byrow = FALSE,dimnames = NULL)

#Saving cluster summary statistics for balancing
for(i in 1:ncol(hclust_cluster_assignments)){  
hclust_sumstats[[i]] <- data.frame(cbind(hclust_cluster_assignments[,i],CCR_covariates))

hclust_sumstats[[i]][,"Cluster_mRate_1"] <- with(hclust_sumstats[[i]], ave(microPos_1, hclust_sumstats[[i]][,1], FUN=sum)) / with(hclust_sumstats[[i]], ave(microTests_1, hclust_sumstats[[i]][,1], FUN=sum))

hclust_sumstats[[i]][,"Cluster_hhDensity"] <- with(hclust_sumstats[[i]], ave(hh, hclust_sumstats[[i]][,1], FUN=sum)) / with(hclust_sumstats[[i]], ave(areakm2, hclust_sumstats[[i]][,1], FUN=sum))

hclust_sumstats[[i]][,"Cluster_prop_BordersWater"] <- with(hclust_sumstats[[i]], ave(as.numeric(BordersWater), hclust_sumstats[[i]][,1], FUN=sum)) / with(hclust_sumstats[[i]], ave(as.numeric(BordersWater), hclust_sumstats[[i]][,1], FUN=length))

#Ensuring sorted by clustering
hclust_sumstats[[i]] <- hclust_sumstats[[i]][order(hclust_sumstats[[i]][,1]),]

#Outputting one row per subgroup summary stats
hclust_sumstats[[i]] <- hclust_sumstats[[i]][!duplicated(hclust_sumstats[[i]][,1]),]

#CCR
hclust_ccr[[i]] <- cvrall(clustername = hclust_sumstats[[i]][,1],
                  balancemetric = "l2",
                  x = data.frame(hclust_sumstats[[i]][ ,CCR_SumStats_Strata]),
                  ntotal_cluster = length(hclust_sumstats[[i]][,1]),
                  ntrt_cluster = length(hclust_sumstats[[i]][,1])/2,
                  weights = c(weights, 1000),
                  categorical = Strata,
                  cutoff = 0.1,
                  size = 25000000,
                  bhist = F,
                  seed = seed)

#Labeling treatment assignments
names(hclust_ccr[[i]]$allocation) <- c(paste("hclust_", length(hclust_sumstats[[i]][,1]), sep = ""), paste("hclust_", length(hclust_sumstats[[i]][,1]), "_trt", sep = ""))

hclust_cluster_assignments_df <- merge(hclust_cluster_assignments_df, hclust_ccr[[i]]$allocation)
hclust_cluster_assignments_df$village_code <- as.character(hclust_cluster_assignments_df$village_code)

#Merging with left_join() to keep row order
hclust_cluster_assignments_df <- left_join(geo_data_df, hclust_cluster_assignments_df)

#Saving separate dataframes of treatment assignments with their spatial location data (coordinates)
trt_loc[[i]] <- data.frame(cbind(select(hclust_cluster_assignments_df, ends_with("_trt"))[i]), geo_data_df)

#Split by treatment group
split_trt_loc[[i]] <- split(trt_loc[[i]], trt_loc[[i]][1])

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
spat_clust[i,] <- ifelse(t.test(nndist(split_trt_loc[[i]]$`0`$village_lat, split_trt_loc[[i]]$`0`$village_long), nndist(split_trt_loc[[i]]$`1`$village_lat, split_trt_loc[[i]]$`1`$village_long))$p.value < 0.05, 1, 0)

#Testing for balance on strata
balanced_strata[i,] <- ifelse(regmatches(levels(hclust_ccr[[i]]$baseline_table$`arm = 0`[5])[1], gregexpr("(?<=\\().*?(?=\\))", levels(hclust_ccr[[i]]$baseline_table$`arm = 0`[5])[1], perl=T))[[1]] == "50.0" && regmatches(levels(hclust_ccr[[i]]$baseline_table$`arm = 1`[5])[1], gregexpr("(?<=\\().*?(?=\\))", levels(hclust_ccr[[i]]$baseline_table$`arm = 1`[5])[1], perl=T))[[1]] == "50.0"
,1,0)

#Saving selected ccr scores
ccr_selected[i,] <- as.numeric(hclust_ccr[[i]]$bscores[1,2])
}

#Combining selected scores, whether or not there is evidence of spatial 
#heterogeneity, and whether or not strata are balanced
ccr_all <- data.frame(ccr_selected,spat_clust,balanced_strata)

#Selecting schemes that are balanced on strata and exhibit spatial heterogeneity
ccr_bal_clust <- ccr_all[which(ccr_all$spat_clust == 1 & ccr_all$balanced_strata == 1),]

#IDing lowest selected score
lowest_index <- as.numeric(rownames(ccr_bal_clust[which.min(ccr_bal_clust[,1]),]))
hclust_best_ccr <- ifelse(length(lowest_index) == 0, NA, hclust_ccr[lowest_index])
seed = seed + 1 
}

paste("Seed: ",seed,sep = "")

#Saving seed
seed_hclust <- seed
seed_mat <- data.matrix(seed_hclust)
colnames(seed_mat) <- "Seed"

#Isolating clustername and treatment arm
hclust_ccr_mat <- cbind(hclust_best_ccr[[1]]$allocation[1], hclust_best_ccr[[1]]$allocation[2])
colnames(hclust_ccr_mat) <- c("hclust_cluster", "hclust_treatment_arm")

#Saving best configuration
hclust_optimized_treatments <- as.matrix(hclust_cluster_assignments[,lowest_index])
hclust_optimized_treatments <- cbind(hclust_optimized_treatments,rownames(hclust_optimized_treatments))
colnames(hclust_optimized_treatments) <- c("hclust_cluster", "village_code")

hclust_optimized_treatments <- merge(hclust_optimized_treatments, hclust_ccr_mat, by = "hclust_cluster")

K_hclust <- max(as.numeric(hclust_optimized_treatments$hclust_cluster))


#Adding treatment allocations to clusters for proper labeling with spplot()
#Cluster assignments
hclust_clustering <- as.matrix(hclust_cluster_assignments[,lowest_index])
colnames(hclust_clustering) <- "hclust_cluster"
#Adding village codes as a variable for linking
hclust_names <- as.matrix(rownames(hclust_clustering))
colnames(hclust_names) <- "village_code"
hclust_clustering <- as.matrix(cbind(hclust_clustering,hclust_names))

#Treatment assignments
hclust_treatments <- as.matrix(hclust_optimized_treatments$hclust_treatment_arm)
rownames(hclust_treatments) <- hclust_optimized_treatments$village_code
colnames(hclust_treatments) <- "Treatment_Group"

hclust_trtnames <- as.matrix(rownames(hclust_treatments))
colnames(hclust_trtnames) <- "village_code"

hclust_treatments <- cbind(hclust_treatments,hclust_trtnames)

#Saving as DFs for merging
hclust_clustering_df <- data.frame(hclust_clustering)
hclust_treatments_df <- data.frame(hclust_treatments)

#Maintaining order of village codes with left_join from dplyr 
hclust_df <- left_join(hclust_clustering_df, hclust_treatments_df, by ="village_code")

#Saving as matrix for spatial plots
hclust_treatments <- as.matrix(hclust_df[,2:3])

#Labeling
village_code <- rownames(geo_data)
colnames(geo_data) <- c("village_long", "village_lat")
#Merging location with unit label
village_coords <- data.frame(cbind(geo_data, village_code))

#Merging centroids with optimized treatment assignments
hclust_best_df <- left_join(hclust_df, village_coords, by ="village_code")
#Merging with ultimate seed
hclust_best_df <- data.frame(hclust_best_df, seed_hclust)
```

####Overall

```{r, echo=T, message=F, warning=F}
best_scores <-  c(as.numeric(kmeans_best_ccr[[1]]$bscores[1,2]),as.numeric(clara_best_ccr[[1]]$bscores[1,2]),as.numeric(hclust_best_ccr[[1]]$bscores[1,2]))
  
if (min(best_scores) == best_scores[1]) {
overall_best_design <- kmeans_best_ccr 
overall_best_design_df <- kmeans_best_df
best<-"K-Means"
K_best <- K_kmeans
best_clustering <- kmeans_clustering
best_treatments <- kmeans_treatments
  paste("The configuration with the lowest selected CCR score, exhibiting spatial heterogeneity of treatment assignments and balance on strata, is ", best, " with ", K_best, " clusters.",sep = "")
  
#Summary stats for best selected design
overall_best_design[[1]]$baseline_table  

#Visualizing clusters
sp::plot(map,border="grey",col=best_clustering[,1], main= paste(K_best,"-Cluster Partition Obtained with ", best, " Clustering \n on Centroid Euclidean Distance", sep = ""),cex.main=1)
legend("bottomleft", legend=paste("Cluster",1:K_best), fill=1:K_best, bty="n",border="white")
text(coordinates(map), labels = best_clustering[,1])

#Visualizing treatment assignments
sp::plot(map,border="grey",col= best_treatments[,2], main= paste("Treatment Allocations Obtained with ", best," Clustering and Weighted CCR", sep = ""),cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")

#Saving design
write.csv(overall_best_design[[1]]$baseline_table, "overall_best_ccr_table_Euclidean.csv")
write.csv(overall_best_design_df, "overall_best_ccr_assignments_Euclidean.csv")
} else if (min(best_scores)==best_scores[2]) {
overall_best_design <- clara_best_ccr
overall_best_design_df <- clara_best_df
best <-"CLARA"
K_best <- K_clara
best_clustering <- clara_clustering
best_treatments <- clara_treatments
  paste("The configuration with the lowest selected CCR score, exhibiting spatial heterogeneity of treatment assignments and balance on strata, is ", best, " with ", K_best, " clusters.",sep = "")
  
#Summary stats for best selected design
overall_best_design$baseline_table  

#Visualizing clusters
sp::plot(map,border="grey",col=best_clustering[,1], main= paste(K_best,"-Cluster Partition Obtained with ", best, " Clustering \n on Centroid Euclidean Distance", sep = ""),cex.main=1)
legend("bottomleft", legend=paste("Cluster",1:K_best), fill=1:K_best, bty="n",border="white")
text(coordinates(map), labels = best_clustering[,1])

#Visualizing treatment assignments
sp::plot(map,border="grey",col= best_treatments[,2], main= paste("Treatment Allocations Obtained with ", best," Clustering and Weighted CCR", sep = ""),cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")

#Saving design
write.csv(overall_best_design[[1]]$baseline_table, "overall_best_ccr_table_Euclidean.csv")
write.csv(overall_best_design_df, "overall_best_ccr_assignments_Euclidean.csv")
} else {
overall_best_design <- hclust_best_ccr
overall_best_design_df <- hclust_best_df
best<-"Ward Hierarchical"
K_best <- K_hclust
best_clustering <- hclust_clustering
best_treatments <- hclust_treatments
  paste("The configuration with the lowest selected CCR score, exhibiting spatial heterogeneity of treatment assignments and balance on strata, is ", best, " with ", K_best, " clusters.",sep = "")

#Visualizing clusters
sp::plot(map,border="grey",col=best_clustering[,1], main= paste(K_best,"-Cluster Partition Obtained with ", best, " Clustering \n on Centroid Euclidean Distance", sep = ""),cex.main=1)
legend("bottomleft", legend=paste("Cluster",1:K_best), fill=1:K_best, bty="n",border="white")
text(coordinates(map), labels = best_clustering[,1])

#Visualizing treatment assignments
sp::plot(map,border="grey",col= best_treatments[,2], main= paste("Treatment Allocations Obtained with ", best," Clustering and Weighted CCR", sep = ""),cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")

#Saving design
write.csv(overall_best_design[[1]]$baseline_table, "overall_best_ccr_table_Euclidean.csv")
write.csv(overall_best_design_df, "overall_best_ccr_assignments_Euclidean.csv")
}

#Treatment assignments and summary stats
overall_best_design_df
overall_best_design[[1]]$baseline_table
overall_best_design[[1]]$bscores
```


