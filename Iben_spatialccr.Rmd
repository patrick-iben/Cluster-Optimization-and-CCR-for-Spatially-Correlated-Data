---
title: Cluster Assignment and Covariate-Constrained Randomization for Spatially-Correlated Data
author: "Patrick Iben"
date: "July 9, 2019"
output:
  html_document: default
  pdf_document: default
---

###Introduction

Cluster randomized trials (CRTs) are commonly implemented when treatments cannot be randomized to individuals. However, randomization of clusters often results in imbalance with respect to important confounders. To circumvent this imbalance, researchers have applied constraints to the covariate make-up of the clusters so that imbalance is minimized, so-called covariate-based constrained randomization (CCR) [1]. Briefly, in CCR, constraints are applied to all possible randomizations, and among those that satisfy these constraints one is chosen at random.

The purpose of this tutorial is to guide developers of randomized clinical trials through the assignment of units to clusters, and clusters to treatment arms via covariate-constrained randomization. For robustness and evaluation of scalability, mixed covariate data types (e.g., numerical, categorical) from both small and large-scale real-world data scenarios are utilized for the optimization, creation, and assignment of clusters. Three popular clustering algorithms currently implemented in R are used and compared: K-means, Clustering Large Applications (CLARA), and Ward-like hierarchical clustering. The algorithms are compared with respect to their: resultant degree of cluster covariate imbalance after CCR assignment (both weighted and unweighted); overall spatial contiguity of treatment arms after CCR; and CPU run times for each major stage of the process - cluster optimization, weighted CCR and unweighted CCR. 

###Methodology

R is used for all data visualization, cluster assignment, and CCR. The "sp" and "ggplot2" packages are used for spatial visualization of data [2,3,4]. All calculations and their CPU run times are derived from a PC with an Intel(R) Core(TM) i7-6500U CPU @ 2.50 GHz processor and 16.0GB of RAM, running Windows 10 on an x64-based processor and R v.3.5.3 (64-Bit).

For K-means, CLARA, and Hierarchical clustering with geographical dissimilarities, optimal clustering number is determined with the wcClusterQuality() function from the "WeightedCluster" package [5]. For Hierarchical clustering with both covariate and geographical dissimilarities, optimal clustering number is determined with the "ClustGeo" package [6]. To measure covariate and geographical dissimilarity between units, and to accommodate mixed data types, the daisy() function in the "cluster" package is used [7].

The cvrall() function from the "cvcrand" package is used to conduct covariate-constrained randomization (CCR), and to compare the overall balancing of subsequent cluster assignment to treatments. Size is set to 25,000,000 - if the total number of randomization schemes exceeds 25,000,000, then cvrall() simulates from the complete randomization space and selects 25,000,000 unique schemes for the randomization sample space [8]. Only the top 10% (in terms of covariate balance) of all possible assignment schemes are considered for random selection - the default cutoff for cvrall(). Thus, the maximum number of assignment schemes to be considered while randomizing for CCR is 2,500,000. 

As CRTs tend to have only two treatment arms for which to randomize clusters (treatment and control), only even number of clusters can be considered to evenly assign units. If only two clusters are created for randomization to treatment arms, then the number of clusters would equal the number of treatments to be assigned, and there would be no reason to perform CCR. If only four clusters are created, then there are a total of six (4 choose 2) configurations to select randomly from for CCR. If the default cutoff for cvrall() of 10% is used, then this leaves only one treatment allocation scheme to select from, thus creating a deterministic selection for cluster assignment - and no longer qualifies as a randomized control trial. To remove this possibility, only even cluster sizes greater than or equal to six are considered. 

To measure the contiguity of treatment arms after CCR, mean nearest neighbor distances (k=1) by treatment arm are found and compared with the nndist() function from the "spatstat" package [9]. If there is no difference in mean nearest neighbor by treatment arms, then there is spatial homogeneity within the study space. As a primary aim of this study is to mitigate spatial contamination of treatment arms, this is unfavorable. Thus, an ideal study design would have spatial heterogeneity of treatment arms (e.g., significantly differing mean nearest neighbor distances). To measure this, Welch Two-Sample Independent t-tests are performed on treatment assignment group mean nearest neighbor distances.

###Data Scenario: Malaria in a localized Uganda community

In malaria research, interventions are often applied to communities, not individuals, such as spraying of insecticides, distribution of medications to health centers, or bed net campaigns. CCR is a potentially beneficial method for assigning treatments to communities. However, spatial heterogeneity needs to be considered, as mosquitoes and people move frequently, and the potential for treatment contamination is high. Thus, it is desirable to optimize community assignment to clusters that are contiguous, yet still achieve random assignment of clusters to intervention arms. 

For this scenario, survey results from 55 villages in Uganda were collected over 5 phases of implementation. For the creation of clusters, villages are matched on either geographical proximity, covariate similarity, or both simultaneously, depending on the limitations of a given clustering algorithm.

```{r, echo=F, message=F, warning=F}
op <- par()
options(width=80)
emptyenv()
rm(list=ls())

### MAPPING PACKAGES ###
#install.packages(c("RColorBrewer", "sp", "maptools", "lattice", "latticeExtra", "rgdal","classInt", "gridExtra","ggplot2","tidyr", "cluster", "ClustGeo", "WeightedCluster", "cvcrand", "spdep", "foreign", "spatstat", "gmodels"))
library(RColorBrewer)
library(sp)
library(maptools) 
library(lattice)
library(latticeExtra) # For layer()
library(rgdal)
library(classInt)
require(gridExtra)
library(ggplot2)
library(tidyr)
library(cluster)
library(ClustGeo)
library(WeightedCluster)
library(cvcrand)
library(spdep)
library(foreign)
library(spatstat)
library(gmodels)

### read in village data
vill <- read.csv('C:/Users/Patrick/Documents/CCR/CCR/study_by_village.csv')
vill2 <- vill[c(1:10, 21, 22)]

#fix village names
library(tools)
vill2$village_name <- toTitleCase(as.character(vill2$village_name))

# get Magoro and Toroma village names
vnames <- read.csv('C:/Users/Patrick/Documents/CCR/CCR/villageNames.csv')

tab3 <- merge(vill2, vnames, by.x = c("subcounty", "village"),
              by.y = c("repcty", "village.2"), all.x = T)
tab3$village_name.y <- as.character(tab3$village_name.y)

tab3$village_name <- tab3$village_name.x
tab3$village_name <- ifelse(is.na(tab3$village_name)==T, tab3$village_name.y, tab3$village_name)
tab3$village_name <- toTitleCase(tolower(tab3$village_name))

lim <- subset(tab3, duplicated(village_code) == F) # dropped 2
lim$village_code <- paste(lim$village, lim$subcounty, sep="_")

# get household by village information
hh <- read.csv('C:/Users/Patrick/Documents/CCR/CCR/hhPerVillage.csv')
hh$village_code <- paste(hh$village, hh$county, sep="_")
hh$village <- NULL
hh$county <- NULL

lim2 <- merge(lim, hh, by="village_code", all.x=T)
#plot(lim2$pop, lim2$population)
#plot(lim2$population, lim2$hh)
lim2$hhDensity <- lim2$hh/lim2$areakm2

vstat <- read.csv('C:/Users/Patrick/Documents/CCR/CCR/surveyResultsByVillage.csv')
vstat$X <- NULL

s5 <- read.csv('C:/Users/Patrick/Documents/CCR/CCR/s5data.csv')
s5lim <- subset(s5, Scounty != 2)
s5lim$survey <- 5

#Merging in survey 5 microscopy data
s5micro <- read.csv("C:/Users/Patrick/Documents/CCR/CCR/s5micros.csv")
s5micro$survey <- 5
s5microlim <- subset(s5micro, Scounty != 2)
colnames(s5microlim)[colnames(s5microlim)=="microsPos"] <- "microPos"
colnames(s5microlim)[colnames(s5microlim)=="microsTests"] <- "microTests"

s5lim <- merge(s5lim, s5microlim, by.x=c("Scounty", "Village", "survey"), 
              by.y=c("Scounty", "Village", "survey"), all = T)

a1 <- merge(vstat, s5lim, by.x=c("county", "village", "survey", "rdtPos", "rdtTests", "microPos", "microTests"), 
              by.y=c("Scounty", "Village", "survey", "rdtPos", "rdtTests", "microPos", "microTests"), all = T)

all <- merge(a1, lim2, by.x = c("county", "village"), 
             by.y = c("subcounty", "village"))
all$village_name.x <- NULL
all$village_name.y <- NULL

all$mrate <- all$microPos/all$microTests
#tapply(all$mrate, all$survey, mean)

all$rrate <- all$rdtPos/all$rdtTests
#tapply(all$rrate, all$survey, mean)

StudyByVillage_noMagoro <- all

StudyByVillage_noMagoro$village_code <- ifelse(nchar(StudyByVillage_noMagoro$village_code)<4, paste(0,StudyByVillage_noMagoro$village_code, sep = ""),StudyByVillage_noMagoro$village_code)

#Adding indicator for bordering lake, areas outside of study
StudyByVillage_noMagoro$BordersWater = ifelse(StudyByVillage_noMagoro$village_code %in% c('01_1', '02_1', '03_1', '04_1', '05_1', '06_1', '07_1', '08_1', '10_1', '12_1', '14_1', '16_1', '17_1', '18_1', '07_3', '08_3', '12_3', '14_3', '17_3', '19_3', '20_3', '25_3', '28_3', '29_3', '32_3', '36_3'),1,0)

#Generically renaming for ease of abstraction
study_data <-StudyByVillage_noMagoro

#Ensuring sorted by hierarchy of data
study_data<- study_data[with(study_data, order(county, village, survey)), ] 

#Transposing long to wide
study_data_wide <- reshape(study_data, idvar = "village_code", sep = "_", timevar = "survey", v.names = c("rdtTests","rdtPos","rrate", "microPos", "microTests", "mrate"),direction = "wide")

#Spatially plotting covariates

#Read in the shape file for villages
poly1 <- readShapePoly("C:/Users/Patrick/Documents/CCR/CCR/pilgrim_africa_villages_shapefile/pilgrim_villages.shp")
#plot(poly1)
#Checking village names in shapefile
#poly1@data
#Not using subcounty 2, subsetting rows 0-54
poly1_noMagoro <- poly1[c(1:55),]

#Comparing and matching row names in dataframe
#row.names(poly1_noMagoro)
row.names(poly1_noMagoro@data) <-poly1_noMagoro@data$village_sc
row.names(poly1_noMagoro) <- row.names(poly1_noMagoro@data)
#row.names(study_data_wide)
rownames(study_data_wide) <- study_data_wide$village_code

#Building spatial poly df

map <- SpatialPolygonsDataFrame(poly1_noMagoro, study_data_wide)

tempPal <- brewer.pal(n = 6, name = "YlOrRd")#N color scheme
waterPal <- brewer.pal(n = 9, name = "YlGnBu")#water color scheme

#Quick visualization of village codes
#colors=rainbow(length(map$village_code))
#plot(map,col=colors)
#text(coordinates(map), labels = map$village_code)

rownames(map@data) <- map$village_code 
```

####Spatial clustering method 1: K-means with Euclidean Dissimilarities

K-means is one of the most widely-used methods to cluster data. Unfortunately, this algorithm is restricted to only numerical data, and thus cannot be used with mixed data types. Let us start by looking at the overall quality of the k-means clustering allocation scheme, without consideration of baseline covariate data and solely on Euclidean distance between village centroids.

First, the unit-dependent spatial variables, provided as village longitude and latitude for this example, are extracted from the shape file using the coordinates() function from the "sp" package [3].

```{r, echo=T, message=F, warning=F}
#Extracting xy coordinates
spatial_data <- coordinates(poly1_noMagoro)
```

The dissimilarity matrix, used to evaluate cluster quality, can be easily created using the daisy() function. For the k-means method, we are selecting the Euclidean distance metric.

```{r, echo=T, message=F, warning=F}
#Calculating dissimilarities between village centroids
dt <- daisy(spatial_data, metric="euclidean")
```

The process of graphically determining optimal clustering sizes for a given dataset is often subjective and thus prone to error. To remove ambiguity from this process, we use the highly-flexible wcClusterQuality() function. The function accepts any clustering scheme and dissimilarity matrix, as well as an optional numerical vector of weights, and returns several quality statistics of a given clustering solution. For the purposes of this tutorial - robust cluster assignment on mixed data - optimal cluster size is determined by the maximum average silhouette width (unweighted).

An array is initialized for each cluster quality statistic value available, for every cluster size value to be tested. For this example, between 6 and 18 (the closest even number of clusters that averages to at least 3 units/cluster for this 55-unit example) clusters are tested. As a reminder, to ensure equal cluster sizes for treatment arms, only even cluster sizes are considered.

```{r, echo=T, message=F, warning=F}
minclust <- 6 #Setting minimum K for cluster size

#Setting maximum K for cluster size to ensure at least 3 units per cluster
n_3 <- round((nrow(study_data_wide))/3)
n_3_even <- ifelse(n_3 %% 2 != 0, n_3-1, n_3)#If odd, subtract 1
#If (closest even number under number of units divided by 3 *3) is greater than number of units, then subtract 2 from previous line for maxclust
maxclust <- ifelse((n_3_even*3) > nrow(study_data_wide), n_3_even-2, n_3_even)
#For this example, 18 clusters max. will be tested.
```

Next, we iteratively collect cluster quality statistics for each cluster size with a for() loop. Note: for reproducibility, a seed is set within the for() loop and before the clustering.

After running through the sensitivity analysis to determine the optimal cluster size and saving the value that optimizes the clustering quality statistic of choice (average silhouette width), the kmeans() clustering algorithm is rerun with the value (note: if several values are equal to the optimal statistic, the minimum K (first value in the array) is selected). The clustering scheme is then extracted and merged back into the main study data. 

```{r, echo=T, message=F, warning=F}
#Getting cluster quality by K
start_time <- Sys.time()#starting timer

clustering_list <- list()#Initializing listing of cluster assignments for each value of K
quality_list <- list()#Initializing listing of cluster value quality for each value of K

#Average Silhouette Width (observation).
ASW <- matrix(data = NA, nrow = maxclust-minclust+1, ncol = 1, byrow = FALSE,dimnames = NULL)
row.names(ASW) <- minclust:maxclust

#Gathering Average Silhouette Width for all cluster sizes between min. and max. cluster size set
for(i in minclust:maxclust){
  set.seed(30)
  clustering_list[[i-(minclust-1)]] <- kmeans(spatial_data, i)$cluster
  quality_list[[i-(minclust-1)]]  <- wcClusterQuality(dt,clustering_list[[i-(minclust-1)]])
  ASW[i-(minclust-1)] <- quality_list[[i-(minclust-1)]]$stats[4]
} 

#If several values equal to the optimal statistic, selects the minimum K (first value in array)
ASW_valid <- ASW[seq(1, nrow(ASW), 2),] #Only looking at even K values for CCR (starting from minimum K)
K_ASW <- as.numeric(names(ASW_valid)[which(ASW_valid == max(ASW_valid), arr.ind = TRUE)])[1]

#Using average silhouette width to determine optimal K
K_kmeans <- K_ASW

end_time <- Sys.time()

#Saving clustering selection run time
K_means_selection_time <- end_time - start_time

#Saving cluster assignments with optimal K
set.seed(30)
K_kmeans_clustering <- as.matrix(clustering_list[[i-(minclust-1)]] <- kmeans(spatial_data, K_kmeans)$cluster)
colnames(K_kmeans_clustering) <- "K_means_Clusters"
#Adding village codes as a variable for linking
K_kmeans_names <- as.matrix(rownames(K_kmeans_clustering))
colnames(K_kmeans_names) <- "village_code"
K_kmeans_clustering <- as.matrix(cbind(K_kmeans_clustering,K_kmeans_names))

#Merging back into main dataset
study_data_wide <- merge(K_kmeans_clustering, study_data_wide,by = "village_code")

#Visualizing clusters
sp::plot(map,border="grey",col=K_kmeans_clustering, main= "12-Cluster Partition Obtained with K-Means on Centroid Euclidean Distance",cex.main=1)
legend("left", legend=paste("Cluster",1:K_kmeans), fill=1:K_kmeans, bty="n",border="white")

#Black and white visualization of clustering scheme
#plot(map, main= "12-Cluster Partition Obtained with K-Means on Centroid Euclidean Distance",cex.main=1 )
#text(coordinates(map), labels = K_kmeans_clustering[,1])
```

#####CCR

"cvcrand" allows for custom weighting of covariate importance while performing CCR. For this example, we use standardized regression coefficients from a Poisson cell-means model with an offset via the glm() function. We are using standardized village-level data (due to the sparsity of cluster-level data); to standardize the data, the scale() function is used. The regression coefficients are standardized such that their absolute values sum to 1 - the relative weight of a given covariate is defined as the absolute value of its model coefficient divided by the sum of the absolute values of all model coefficients. 

```{r, echo=T, message=F, warning=F}
#Scaling covariates (not outcome or offset)
study_data_wide$scaled_microPos_1 <- scale(study_data_wide$microPos_1)
study_data_wide$scaled_BordersWater <- scale(study_data_wide$BordersWater)
study_data_wide$scaled_hhDensity <- scale(study_data_wide$hhDensity)

weight_model <- glm(microPos_5 ~ scaled_microPos_1 + scaled_BordersWater + scaled_hhDensity+ offset(log(microTests_5)) -1, 
                 data=study_data_wide, family = poisson)
summary(weight_model)

#Scaling and saving weights
weights <- c(abs(weight_model$coefficients[1][[1]])/sum(abs(weight_model$coefficients)), abs(weight_model$coefficients[2][[1]])/sum(abs(weight_model$coefficients)), abs(weight_model$coefficients[3][[1]])/sum(abs(weight_model$coefficients)))

weights #0.5057831 0.2225534 0.2716635
```

"cvcrand" only allows for data sets with row number equal to the number of clusters. Thus, we first aggregate our unit-level covariate data into cluster-level summary statistics. 

```{r, echo=T, message=F, warning=F}
#Subsetting variables of interest, cluster assignments
kmeans_assignments_reduced <- study_data_wide[,c("K_means_Clusters","microPos_5","microPos_1", "microTests_5","microTests_1", "BordersWater", "hhDensity")]

#Getting aggregate statistics by clusters
kmeans_assignments_reduced$Cluster_Sum_mPos_5 <- with(kmeans_assignments_reduced, ave(microPos_5, K_means_Clusters, FUN=sum))

kmeans_assignments_reduced$Cluster_Sum_mPos_1 <- with(kmeans_assignments_reduced, ave(microPos_1, K_means_Clusters, FUN=sum))

kmeans_assignments_reduced$Cluster_Sum_mTest_5 <- with(kmeans_assignments_reduced, ave(microTests_5, K_means_Clusters, FUN=sum))

kmeans_assignments_reduced$Cluster_Sum_mTest_1 <- with(kmeans_assignments_reduced, ave(microTests_1, K_means_Clusters, FUN=sum))

kmeans_assignments_reduced$Cluster_mRate_5 <- kmeans_assignments_reduced$Cluster_Sum_mPos_5 / kmeans_assignments_reduced$Cluster_Sum_mTest_5

kmeans_assignments_reduced$Cluster_mRate_1 <- kmeans_assignments_reduced$Cluster_Sum_mPos_1 / kmeans_assignments_reduced$Cluster_Sum_mTest_1

kmeans_assignments_reduced$Cluster_Med_hhDensity <- with(kmeans_assignments_reduced, ave(hhDensity, K_means_Clusters, FUN=median))

kmeans_assignments_reduced$Cluster_MeanProp_BordersWater <- with(kmeans_assignments_reduced, ave(as.numeric(BordersWater)-1, K_means_Clusters, FUN=mean))

#ensuring sorted by clustering
kmeans_assignments_reduced <- kmeans_assignments_reduced[order(kmeans_assignments_reduced$K_means_Clusters),]

#outputting one row per subgroup summary stats
kmeans_assignments_reduced <- kmeans_assignments_reduced[!duplicated(kmeans_assignments_reduced$K_means_Clusters),]
```

To perform the CCR, the cvrall() function from the "cvcrand" package is used.

Weighted:

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Weighted CCR
kmeans_Weighted_Design_result <- cvrall(clustername = kmeans_assignments_reduced$K_means_Clusters,
                  balancemetric = "l2",
                  x = data.frame(kmeans_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = nrow(kmeans_assignments_reduced),
                  ntrt_cluster = nrow(kmeans_assignments_reduced)/2,
                  weights = weights,
                  size = 25000000,
                  cutoff = 0.1,
                  seed = 12345)

end_time <- Sys.time()

#Saving ccr run time
Weighted_K_means_ccr_time <- end_time - start_time

#Allocation scheme
#kmeans_Weighted_Design_result$allocation

#Descriptive statistics for all the variables by the two arms from the selected scheme
#kmeans_Weighted_Design_result$baseline_table

#Dataframe with treatment allocations
#kmeans_Weighted_Design_result$data_CR

#Adding the treatment assignments to the dataframe for visualization
weighted_allocations_kmeans <- kmeans_Weighted_Design_result$allocation
colnames(weighted_allocations_kmeans) <- c("K_means_Clusters","Weighted_K_means_Treatment_Allocation")
study_data_wide <- merge(weighted_allocations_kmeans, study_data_wide, by= "K_means_Clusters")

#Adding treatment allocations to clusters for proper labeling with spplot()
#Matching rows with SpatialPolygonsDataframe
K_kmeans_clustering <- as.data.frame(K_kmeans_clustering)
K_kmeans_clustering$id <- 1:nrow(K_kmeans_clustering)
Kmeans_clusters_weighted_ccr_1 <- merge(K_kmeans_clustering,weighted_allocations_kmeans, by = "K_means_Clusters")
Kmeans_clusters_weighted_ccr_1 <- Kmeans_clusters_weighted_ccr_1[order(Kmeans_clusters_weighted_ccr_1$id), ]
#Subsetting village code and clusters
Kmeans_clusters_weighted_ccr_1 <- Kmeans_clusters_weighted_ccr_1[,c(4,2)]
rownames(Kmeans_clusters_weighted_ccr_1) <- Kmeans_clusters_weighted_ccr_1[,2]#labeling rows

#Balance score for min. scheme
weighted_kmeans_ccr_min_score <- as.numeric(kmeans_Weighted_Design_result$bscores[5,2])#0.084
#Balance score for selected scheme
weighted_kmeans_ccr_selected_score <- as.numeric(kmeans_Weighted_Design_result$bscores[1,2])#0.263
#Balance score for 10% cutoff scheme
weighted_kmeans_ccr_cutoff_score <- as.numeric(kmeans_Weighted_Design_result$bscores[2,2])#0.299
#Balance score for max. scheme
weighted_kmeans_ccr_max_score <- as.numeric(kmeans_Weighted_Design_result$bscores[14,2])#4.737
```

Unweighted:

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Unweighted CCR
kmeans_Unweighted_Design_result <- cvrall(clustername = kmeans_assignments_reduced$K_means_Clusters,
                  balancemetric = "l2",
                  x = data.frame(kmeans_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = length(kmeans_assignments_reduced$K_means_Clusters),
                  ntrt_cluster = length(kmeans_assignments_reduced$K_means_Clusters)/2,
                  cutoff = 0.1,
                  size = 25000000,
                  seed = 12345)

end_time <- Sys.time()

#Saving ccr run time
Unweighted_K_means_ccr_time <- end_time - start_time

#Allocation scheme
#kmeans_Unweighted_Design_result$allocation

#Descriptive statistics for all the variables by the two arms from the selected scheme
#kmeans_Unweighted_Design_result$baseline_table

#Dataframe with treatment allocations
#kmeans_Unweighted_Design_result$data_CR

#Adding the treatment assignments to the dataframe for visualization
allocations_unweighted_kmeans <- kmeans_Unweighted_Design_result$allocation
colnames(allocations_unweighted_kmeans) <- c("K_means_Clusters","Unweighted_K_means_Treatment_Allocation")
study_data_wide <- merge(allocations_unweighted_kmeans, study_data_wide, by= "K_means_Clusters")

#Adding treatment allocations to clusters for proper labeling with spplot()
#Matching rows with SpatialPolygonsDataframe
Kmeans_clusters_unweighted_ccr_1 <- merge(K_kmeans_clustering,allocations_unweighted_kmeans, by = "K_means_Clusters")
Kmeans_clusters_unweighted_ccr_1 <- Kmeans_clusters_unweighted_ccr_1[order(Kmeans_clusters_unweighted_ccr_1$id), ]

#Subsetting village code and clusters
Kmeans_clusters_unweighted_ccr_1 <- Kmeans_clusters_unweighted_ccr_1[,c(4,2)]
rownames(Kmeans_clusters_unweighted_ccr_1) <- Kmeans_clusters_unweighted_ccr_1[,2]#labeling rows

#Balance score for min. scheme
unweighted_kmeans_ccr_min_score <- as.numeric(kmeans_Unweighted_Design_result$bscores[5,2])#1.358
#Balance score for selected scheme
unweighted_kmeans_ccr_selected_score <- as.numeric(kmeans_Unweighted_Design_result$bscores[1,2])#3.34
#Balance score for 10% cutoff scheme
unweighted_kmeans_ccr_cutoff_score <- as.numeric(kmeans_Unweighted_Design_result$bscores[2,2])#3.671
#Balance score for max. scheme
unweighted_kmeans_ccr_max_score <- as.numeric(kmeans_Unweighted_Design_result$bscores[14,2])#39.751

```

#####Measuring contiguity of treatment assignments

To measure the dispersion of treatment arms, nearest neighbor distance is found with the nndist() function from the "spatstat" package and treatment arm-level 95% confidence-level summary statistics calculated with the ci() function from the "gmodels" package. The t.test() function from base R is then used to store whether or not a significant difference was found (alpha = 0.05).

Nearest first neighbor (k = 1):

```{r, echo=T, message=F, warning=F}
#Weighted
#Treatment 0
Weighted_kmeans_treatment_0 <- subset(study_data_wide,study_data_wide$Weighted_K_means_Treatment_Allocation ==0)
Weighted_kmeans_treatment_0 <- cbind(Weighted_kmeans_treatment_0$village_long, Weighted_kmeans_treatment_0$village_lat)

#Treatment 1
Weighted_kmeans_treatment_1 <- subset(study_data_wide,study_data_wide$Weighted_K_means_Treatment_Allocation ==1)
Weighted_kmeans_treatment_1 <- cbind(Weighted_kmeans_treatment_1$village_long, Weighted_kmeans_treatment_1$village_lat)

#Saving CIs for mean nearest-neighbor distance, by treatment allocation
Weighted_kmeans_treatment_0_nndistCI_k1 <- ci(nndist(Weighted_kmeans_treatment_0), confidence = 0.95)
Weighted_kmeans_treatment_1_nndistCI_k1 <- ci(nndist(Weighted_kmeans_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Weighted_kmeans_ttest_k1 <- t.test(nndist(Weighted_kmeans_treatment_0), nndist(Weighted_kmeans_treatment_1))
Weighted_kmeans_different_meanNNdists_k1 <- ifelse(Weighted_kmeans_ttest_k1$p.value < 0.05, 1, 0)

#Unweighted
#Treatment 0
Unweighted_kmeans_treatment_0 <- subset(study_data_wide,study_data_wide$Unweighted_K_means_Treatment_Allocation ==0)
Unweighted_kmeans_treatment_0 <- cbind(Unweighted_kmeans_treatment_0$village_long, Unweighted_kmeans_treatment_0$village_lat)

#Treatment 1
Unweighted_kmeans_treatment_1 <- subset(study_data_wide,study_data_wide$Unweighted_K_means_Treatment_Allocation ==1)
Unweighted_kmeans_treatment_1 <- cbind(Unweighted_kmeans_treatment_1$village_long, Unweighted_kmeans_treatment_1$village_lat)


#Saving CIs for mean nearest-neighbor distance, by treatment allocation
Unweighted_kmeans_treatment_0_nndistCI_k1 <- ci(nndist(Unweighted_kmeans_treatment_0), confidence = 0.95)
Unweighted_kmeans_treatment_1_nndistCI_k1 <- ci(nndist(Unweighted_kmeans_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Unweighted_kmeans_ttest_k1 <- t.test(nndist(Unweighted_kmeans_treatment_0), nndist(Unweighted_kmeans_treatment_1))
Unweighted_kmeans_different_meanNNdists_k1 <- ifelse(Unweighted_kmeans_ttest_k1$p.value < 0.05, 1, 0)
```

####Spatial clustering method 2: Clustering Large Applications (CLARA) with Euclidean Distance

To perform CLARA, we use the clara() function from the "cluster" package [10]. By partitioning using an actual data point located in the middle of a group of points, as opposed to an average central location with k-means, CLARA may be less sensitive to outliers.

To determine the optimal number of clusters, the same methodology provided above for k-means is used.

Let us re-initialize an array for our cluster quality statistic (average silhouette width), for every cluster size value to be tested. Again, we test between 6 and 18 clusters, and only even cluster sizes are considered.

```{r, echo=T, message=F, warning=F}
#Average Silhouette width (observation).
ASW <- matrix(data = NA, nrow = maxclust-minclust+1, ncol = 1, byrow = FALSE,dimnames = NULL)
row.names(ASW) <- minclust:maxclust
```

Next, we iteratively collect the cluster quality statistic for each cluster size with a for() loop (note: if several values are equal to the optimal statistic, the minimum K (first value in the array) is selected). 

```{r, echo=T, message=F, warning=F}
#Getting cluster quality by K
start_time <- Sys.time()

clustering_list <- list()#Initializing listing of cluster assignments for each value of K
quality_list <- list()#Initializing listing of cluster value quality for each value of K

for(i in minclust:maxclust){
  set.seed(30)
  clustering_list[[i-(minclust-1)]] <- clara(spatial_data, metric = "euclidean", k = i)$cluster
  quality_list[[i-(minclust-1)]]  <- wcClusterQuality(dt,clustering_list[[i-(minclust-1)]])
  ASW[i-(minclust-1)] <- quality_list[[i-(minclust-1)]]$stats[4]
} 

#If several values equal to the minimized difference, selects the minimum K (first value in array)

ASW_valid <- ASW[seq(1, nrow(ASW), 2),] #Only looking at even K values for CCR (starting from minimum K)
K_ASW <- as.numeric(names(ASW_valid)[which(ASW_valid == max(ASW_valid), arr.ind = TRUE)])[1]

#Using average silhouette width to determine optimal K
K_clara <- K_ASW

end_time <- Sys.time()

#Saving clustering selection run time
clara_selection_time <- end_time - start_time

```

After running through the sensitivity analysis to determine the optimal cluster size and saving the value, the clara() clustering algorithm is rerun with this value. The clustering scheme is then extracted and merged back into the main study data.

```{r, echo=T, message=F, warning=F}
#Saving cluster assignments with optimal K
K_clara_clustering <- as.matrix(clustering_list[[i-(minclust-1)]] <- clara(spatial_data, metric = "euclidean", k = K_clara)$cluster)
colnames(K_clara_clustering) <- "CLARA_Clusters"

#Adding village codes as a variable for linking
K_clara_names <- as.matrix(rownames(K_clara_clustering))
colnames(K_clara_names) <- "village_code"
K_clara_clustering <- as.matrix(cbind(K_clara_clustering,K_clara_names))

#Merging back into main dataset
study_data_wide <- merge(K_clara_clustering, study_data_wide,by = "village_code")

#Visualizing clusters
sp::plot(map,border="grey",col=K_clara_clustering, main= "8-Cluster Partition Obtained with CLARA on Centroid Euclidean Distance",cex.main=1)
legend("bottomleft", legend=paste("Cluster",1:K_clara), fill=1:K_clara, bty="n",border="grey")

#Black and white
#plot(map, main="8-Cluster Partition Obtained with CLARA on Centroid Euclidean Distance" ,cex.main=1)
#text(coordinates(map), labels = K_clara_clustering[,1])

```

#####CCR

Before performing CCR again, we must create cluster-level summary statistics with the new clustering scheme.

```{r, echo=T, message=F, warning=F}
#Subsetting variables (including cluster assignments)
clara_assignments_reduced <- study_data_wide[,c("CLARA_Clusters","microPos_5","microPos_1", "microTests_5","microTests_1", "BordersWater", "hhDensity")]

#Getting cluster-level statistics
clara_assignments_reduced$Cluster_Sum_mPos_5 <- with(clara_assignments_reduced, ave(microPos_5, CLARA_Clusters, FUN=sum))

clara_assignments_reduced$Cluster_Sum_mPos_1 <- with(clara_assignments_reduced, ave(microPos_1, CLARA_Clusters, FUN=sum))

clara_assignments_reduced$Cluster_Sum_mTest_5 <- with(clara_assignments_reduced, ave(microTests_5, CLARA_Clusters, FUN=sum))

clara_assignments_reduced$Cluster_Sum_mTest_1 <- with(clara_assignments_reduced, ave(microTests_1, CLARA_Clusters, FUN=sum))

clara_assignments_reduced$Cluster_mRate_5 <- clara_assignments_reduced$Cluster_Sum_mPos_5 / clara_assignments_reduced$Cluster_Sum_mTest_5

clara_assignments_reduced$Cluster_mRate_1 <- clara_assignments_reduced$Cluster_Sum_mPos_1 / clara_assignments_reduced$Cluster_Sum_mTest_1

clara_assignments_reduced$Cluster_Med_hhDensity <- with(clara_assignments_reduced, ave(hhDensity, CLARA_Clusters, FUN=median))

clara_assignments_reduced$Cluster_MeanProp_BordersWater <- with(clara_assignments_reduced, ave(BordersWater, CLARA_Clusters, FUN=mean))

#ensuring sorted by clustering
clara_assignments_reduced <- clara_assignments_reduced[order(clara_assignments_reduced$CLARA_Clusters),]

#outputting one row per subgroup summary stats
clara_assignments_reduced <- clara_assignments_reduced[!duplicated(clara_assignments_reduced$CLARA_Clusters),]
```

CLARA Weighted:

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Weighted CCR
CLARA_Weighted_Design_result <- cvrall(clustername = clara_assignments_reduced$CLARA_Clusters,
                  balancemetric = "l2",
                  x = data.frame(clara_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = nrow(clara_assignments_reduced),
                  ntrt_cluster = nrow(clara_assignments_reduced)/2,
                  weights = weights,
                  cutoff = 0.1,
                  size = 25000000,
                  seed = 12345)

#Allocation scheme
#CLARA_Weighted_Design_result$allocation

# the descriptive statistics for all the variables by the two arms from the selected scheme
#CLARA_Weighted_Design_result$baseline_table

#Dataframe with treatment allocations
#CLARA_Weighted_Design_result$data_CR

end_time <- Sys.time()

#Saving ccr run time
Weighted_clara_ccr_time <- end_time - start_time

#Adding the treatment assignments to the dataframe for visualization
clara_weighted_allocations <- CLARA_Weighted_Design_result$allocation
colnames(clara_weighted_allocations) <- c("CLARA_Clusters","Weighted_CLARA_Treatment_Allocation")
study_data_wide <- merge(clara_weighted_allocations, study_data_wide, by= "CLARA_Clusters")

#Adding treatment allocations to clusters for proper labeling with spplot()
#Matching rows with SpatialPolygonsDataframe
K_clara_clustering <- as.data.frame(K_clara_clustering)
K_clara_clustering$id <- 1:nrow(K_clara_clustering)
clara_clusters_weighted_ccr_1 <- merge(K_clara_clustering,clara_weighted_allocations, by = "CLARA_Clusters")
clara_clusters_weighted_ccr_1 <- clara_clusters_weighted_ccr_1[order(clara_clusters_weighted_ccr_1$id), ]
#Subsetting village code and clusters
clara_clusters_weighted_ccr_1 <- clara_clusters_weighted_ccr_1[,c(4,2)]
rownames(clara_clusters_weighted_ccr_1) <- clara_clusters_weighted_ccr_1[,2]#labeling rows

#Balance score for min scheme
weighted_clara_ccr_min_score <- as.numeric(CLARA_Weighted_Design_result$bscores[5,2])#0.066
#Balance score for selected scheme
weighted_clara_ccr_selected_score <- as.numeric(CLARA_Weighted_Design_result$bscores[1,2])#0.093
#Balance score for cutoff scheme
weighted_clara_ccr_cutoff_score <- as.numeric(CLARA_Weighted_Design_result$bscores[2,2])#0.112
#Balance score for max scheme
weighted_clara_ccr_max_score <- as.numeric(CLARA_Weighted_Design_result$bscores[14,2])#1.886
```

CLARA Unweighted:

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Unweighted CCR
CLARA_Unweighted_Design_result <- cvrall(clustername = clara_assignments_reduced$CLARA_Clusters,
                  balancemetric = "l2",
                  x = data.frame(clara_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = nrow(clara_assignments_reduced),
                  ntrt_cluster = nrow(clara_assignments_reduced)/2,
                  size = 25000000,
                  cutoff = 0.1,
                  seed = 12345)

#Allocation scheme
#CLARA_Unweighted_Design_result$allocation

# the descriptive statistics for all the variables by the two arms from the selected scheme
#CLARA_Unweighted_Design_result$baseline_table

#Dataframe with treatment allocations
#CLARA_Unweighted_Design_result$data_CR

end_time <- Sys.time()

#Saving ccr run time
Unweighted_clara_ccr_time <- end_time - start_time

#Adding the treatment assignments to the dataframe for visualization
clara_unweighted_allocations <- CLARA_Unweighted_Design_result$allocation
colnames(clara_unweighted_allocations) <- c("CLARA_Clusters","Unweighted_CLARA_Treatment_Allocation")
study_data_wide <- merge(clara_unweighted_allocations, study_data_wide, by= "CLARA_Clusters")

#Adding treatment allocations to clusters for proper labeling with spplot()
#Matching rows with SpatialPolygonsDataframe
clara_clusters_unweighted_ccr_1 <- merge(K_clara_clustering,clara_unweighted_allocations, by = "CLARA_Clusters")
clara_clusters_unweighted_ccr_1 <- clara_clusters_unweighted_ccr_1[order(clara_clusters_unweighted_ccr_1$id), ]
#Subsetting village code and clusters
clara_clusters_unweighted_ccr_1 <- clara_clusters_unweighted_ccr_1[,c(4,2)]
rownames(clara_clusters_unweighted_ccr_1) <- clara_clusters_unweighted_ccr_1[,2]#labeling rows

#Balance score for min scheme
unweighted_clara_ccr_min_score <- as.numeric(CLARA_Unweighted_Design_result$bscores[5,2])#0.716
#Balance score for selected scheme
unweighted_clara_ccr_selected_score <- as.numeric(CLARA_Unweighted_Design_result$bscores[1,2])#0.776
#Balance score for cutoff scheme
unweighted_clara_ccr_cutoff_score <- as.numeric(CLARA_Unweighted_Design_result$bscores[2,2])#1.767
#Balance score for max scheme
unweighted_clara_ccr_max_score <- as.numeric(CLARA_Unweighted_Design_result$bscores[14,2])#12.921
```

Comparing the dispersion of treatment arms on nearest neighbor distance (k = 1):

```{r, echo=T, message=F, warning=F}
#Weighted CCR
Weighted_clara_treatment_0 <- subset(study_data_wide,study_data_wide$Weighted_CLARA_Treatment_Allocation ==0)
Weighted_clara_treatment_0 <- cbind(Weighted_clara_treatment_0$village_long,Weighted_clara_treatment_0$village_lat)

Weighted_clara_treatment_1 <- subset(study_data_wide,study_data_wide$Weighted_CLARA_Treatment_Allocation ==1)
Weighted_clara_treatment_1 <- cbind(Weighted_clara_treatment_1$village_long,Weighted_clara_treatment_1$village_lat)

#Saving CIs for mean nearest-neighbor distance, by treatment allocation
#Treatment 0
Weighted_clara_treatment_0_nndistCI_k1 <- ci(nndist(Weighted_clara_treatment_0), confidence = 0.95)
#Treatment 1
Weighted_clara_treatment_1_nndistCI_k1 <- ci(nndist(Weighted_clara_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Weighted_clara_ttest_k1 <- t.test(nndist(Weighted_clara_treatment_0), nndist(Weighted_clara_treatment_1))
Weighted_clara_different_meanNNdists_k1 <- ifelse(Weighted_clara_ttest_k1$p.value < 0.05, 1, 0)

#Unweighted CCR
Unweighted_clara_treatment_0 <- subset(study_data_wide,study_data_wide$Unweighted_CLARA_Treatment_Allocation ==0)
Unweighted_clara_treatment_0 <- cbind(Unweighted_clara_treatment_0$village_long, Unweighted_clara_treatment_0$village_lat)

Unweighted_clara_treatment_1 <- subset(study_data_wide,study_data_wide$Unweighted_CLARA_Treatment_Allocation ==1)
Unweighted_clara_treatment_1 <- cbind(Unweighted_clara_treatment_1$village_long, Unweighted_clara_treatment_1$village_lat)

#Saving CIs for mean nearest-neighbor distance, by treatment allocation
Unweighted_clara_treatment_0_nndistCI_k1 <- ci(nndist(Unweighted_clara_treatment_0), confidence = 0.95)
Unweighted_clara_treatment_1_nndistCI_k1 <- ci(nndist(Unweighted_clara_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Unweighted_clara_ttest_k1 <- t.test(nndist(Unweighted_clara_treatment_0), nndist(Unweighted_clara_treatment_1))
Unweighted_clara_different_meanNNdists_k1 <- ifelse(Unweighted_clara_ttest_k1$p.value < 0.05, 1, 0)
```


####Mixed data clustering method: Ward-like hierarchical clustering with optimized weighting of geographic-to-covariate dissimilarities 

Let us take a quick look at our covariates of interest for this example: 

Whether or not the unit (village) borders water (Y/N):

```{r, echo=T, message=F, warning=F}
#Spatially plotting covariates of interest
#borders water indicator
map$BordersWater <- as.factor(map$BordersWater)
sp_out_BordersWater <- spplot(map, c("BordersWater"), 
       colorkey=list(space="right"), scales = list(draw = TRUE), 
       main = "Borders Water?", as.table = TRUE, 
       col.regions = waterPal, col = "transparent", cuts = 1)
sp_out_BordersWater
```

Unit household density:

```{r, echo=T, message=F, warning=F}
#hh density
sp_out_hhDensity <- spplot(map, c("hhDensity"), 
       colorkey=list(space="right"), scales = list(draw = TRUE), 
       main = "Village Household Density", as.table = TRUE, 
       col.regions = waterPal, col = "transparent", cuts = 8)
sp_out_hhDensity
```

Recent survey positive microscopy rate:

```{r, echo=T, message=F, warning=F}
#microscopy rate, each phase
#sp_out_mrate <-spplot(map, c("mrate_1","mrate_2", "mrate_3", "mrate_4", "mrate_5"), 
#      names.attr = c("Survey 1","Survey 2","Survey 3", "Survey 4", "Survey 5"), 
#       colorkey=list(space="right"), scales = list(draw = TRUE), 
#       main = "Positive Microscopy Rate, by Survey", as.table = TRUE, 
#       col.regions = tempPal, col = "transparent", cuts = 5)
#sp_out_mrate

sp_out_mrate5 <-spplot(map, c("mrate_5"), 
       names.attr = c("Survey 5"), 
       colorkey=list(space="right"), scales = list(draw = TRUE), 
       main = "Positive Microscopy Rate, Survey 5", as.table = TRUE, 
       col.regions = tempPal, col = "transparent", at = seq(0, 0.5, 0.1))
sp_out_mrate5

```

The ""Clustgeo" package allows users to achieve Ward-Like hierarchical clustering with non-Euclidean dissimilarity measures, and non-uniform weight. This allows accommodation of mixed data types (e.g., numeric, ordinal, binary), which may often be used for spatial feature data. 

We start by extracting the primary spatial feature covariate data for the study. For this example, our spatial feature data is: recent survey positive microscopy rate for malaria; whether or not a unit borders water; and unit house-hold density.

```{r, echo=T, message=F, warning=F}
#Extracting covariate data for D0 Dissimilarity matrix
study_data_wide$BordersWater <- as.factor(study_data_wide$BordersWater)
dat <- study_data_wide[,c("mrate_5", "BordersWater", "hhDensity")]
#Assigning village code as row name for reference
rownames(dat) <- study_data_wide$village_code
```

Next, using the daisy() function from the "cluster" package, we create dissimilarity matrices for the covariates and geographical location variables separately. In addition to accommodating non-Euclidean dissimilarities, the "Clustgeo" package allows for weighting of spatial feature and geographical dissimilarity importance during cluster assignment. To test the varying weightings of dissimilarity matrices for our mixed data types, Gower dissimilarity is utilized for spatial feature data using the daisy() function - with metric set to "gower". Briefly, Gower dissimilarity uses the Dice coefficient for binary data and range-normalized Manhattan distance for numeric data [11].

```{r, echo=T, message=F, warning=F}
#Creating D0 and D1 for cluster assignment
#Using Gower distance to accomodate mixed variable types (full matrix)
D0 = as.matrix(daisy(dat, metric = "gower"))
#Triangular matrix dist object used for calculating cluster quality
D0_dist = as.dist(D0)

#D1: geographical distance
D1 = as.matrix(daisy(spatial_data, metric = "euclidean"))
D1_dist = as.dist(D1)
```

#####Determining optimal cluster size and weighting of dissimilarity matrices

The weighting for dissimilarity matrix importance ranges from 0 to 1, in increments of 0.1 - called alpha by developers. According to the developers of the package, 0 represents full weighting on spatial feature data, 1 full weighting on geographical location. To determine the optimal cluster size and alpha level, we use the choicealpha() function from the "Clustgeo" package to calculate the proportion of explained psuedo-inertia for each cluster size of interest. The optimal alpha level is determined by the value at which the difference between the explained pseudo-inertia for covariate and geographical dissimilarity is minimized. If several values are equal to the minimized difference, then the minimum alpha value is selected.

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()#start timer

#setting maxclust for "ClustGeo"
maxclust_hclust <- ifelse(maxclust > 54, 54, maxclust)

#initializing empty sets to store explained psuedo-inertia
cr <- rep(list(NA), maxclust-minclust+1)

Q0 <- matrix(data = NA, nrow = maxclust-minclust+1, ncol = 11, byrow = FALSE,dimnames = NULL)
row.names(Q0) <- minclust:maxclust
colnames(Q0) <- c(seq(0.0, 1.0, 0.1))

Q1 <- matrix(data = NA, nrow = maxclust-minclust+1, ncol = 11, byrow = FALSE,dimnames = NULL)
row.names(Q1) <- minclust:maxclust
colnames(Q1) <- c(seq(0.0, 1.0, 0.1))

range.alpha <- seq(0,1,0.1)

#Gathering proportions of explained pseudo intertia, for every alpha and cluster size
for (w in 1:11) {
for(i in minclust:maxclust_hclust){
cr[[i-(minclust-1)]] <- choicealpha(D0_dist,D1_dist,range.alpha,i,graph=FALSE)
 # proportion of explained pseudo inertia
Q0[i-(minclust-1),w] <- cr[[i-(minclust-1)]]$Q[,1][w]
Q1[i-(minclust-1),w] <- cr[[i-(minclust-1)]]$Q[,2][w]
}}

#Minimizing difference between Q0 and Q1. Subsetting only even clusterings
Q0_Q1_diff <- abs(Q0-Q1)

Q0_Q1_diff_valid <- Q0_Q1_diff[seq(1, nrow(Q0_Q1_diff), 2), ] #Only looking at even K values for CCR (starting from minimum K) 

#Selecting optimal K
K_hclust <- as.numeric(rownames(Q0_Q1_diff_valid)[which(Q0_Q1_diff_valid == min(Q0_Q1_diff_valid), arr.ind = TRUE)][1])

#Selecting optimal alpha 
alpha_hclust <- as.numeric(colnames(Q0_Q1_diff_valid)[which(Q0_Q1_diff_valid == min(Q0_Q1_diff_valid), arr.ind = TRUE)][2])
#If several values equal to the minimized difference, selects the minimum alpha
alpha_hclust <- ifelse(is.na(alpha_hclust),  (which(Q0_Q1_diff_valid == min(Q0_Q1_diff_valid), arr.ind = TRUE)[1,2] - 1 )/ 10, alpha_hclust)

end_time <- Sys.time()#Stop timer

#Saving clustering run time
hclust_selection_time <- end_time - start_time
```

To perform the clustering, the hclustgeo() function from the "Clustgeo" package is used. Unlike the standard hclust() function, hclustgeo() can automatically accommodate non-Euclidean dissimilarities, as well as custom weighting of the dendrogram arms (clusters). To keep consistent with K-means and CLARA, no weighting is used.

```{r, echo=T, message=F, warning=F}
#Performing hierarchical clustering
tree <- hclustgeo(D0_dist,D1_dist,alpha=alpha_hclust)
PKbis <- cutree(tree,K_hclust)#Making K cuts

#Extracting clustering scheme
PKbis_mat <- as.matrix(PKbis)
row.names(PKbis_mat) <- names(PKbis)
colnames(PKbis_mat) <- "Hierarch_Clusters"

#Adding village codes as a variable for linking
hclust_names <- as.matrix(rownames(PKbis_mat))
colnames(hclust_names) <- "village_code"
PKbis_mat <- as.matrix(cbind(PKbis_mat,hclust_names))

#Merging back hclust scheme
study_data_wide <- merge(PKbis_mat, study_data_wide, by="village_code")
colnames(PKbis_mat) <- c("Hierarch_Clusters", "village_sc")#Renaming to match SpatialPolygonsDataframe
poly1_noMagoro@data <- merge(PKbis_mat, poly1_noMagoro@data, by="village_sc")

#Resetting row names as a failsafe measure
row.names(study_data_wide) <- study_data_wide$village_code

#Plotting 
sp::plot(map,border="grey",col=PKbis, main= "Ward-Like Hierarchical Clustering of Size 18 Obtained with alpha=0.6",cex.main=1)
legend("topleft", legend=paste("Cluster",1:max(PKbis)), fill=1:max(PKbis), bty="n",border="grey", cex=0.8)
text(coordinates(map), labels = PKbis)

#Black and white
#plot(map, main="Ward-Like Hierarchical Clustering of Size 18 Obtained with alpha=0.6",cex.main=2)
#text(coordinates(map), labels = PKbis, cex = 2)
```

#####CCR for Ward-like Hierarchical Clustering

```{r, echo=T, message=F, warning=F}
#Getting cluster-level statistics for hierarchical clustering scheme
hclust_assignments_reduced <- study_data_wide[,c("Hierarch_Clusters","microPos_5","microPos_1", "microTests_5","microTests_1", "BordersWater", "hhDensity")]

hclust_assignments_reduced$Cluster_Sum_mPos_5 <- with(hclust_assignments_reduced, ave(microPos_5, Hierarch_Clusters, FUN=sum))

hclust_assignments_reduced$Cluster_Sum_mPos_1 <- with(hclust_assignments_reduced, ave(microPos_1, Hierarch_Clusters, FUN=sum))

hclust_assignments_reduced$Cluster_Sum_mTest_5 <- with(hclust_assignments_reduced, ave(microTests_5, Hierarch_Clusters, FUN=sum))

hclust_assignments_reduced$Cluster_Sum_mTest_1 <- with(hclust_assignments_reduced, ave(microTests_1, Hierarch_Clusters, FUN=sum))

hclust_assignments_reduced$Cluster_mRate_5 <- hclust_assignments_reduced$Cluster_Sum_mPos_5 / hclust_assignments_reduced$Cluster_Sum_mTest_5

hclust_assignments_reduced$Cluster_mRate_1 <- hclust_assignments_reduced$Cluster_Sum_mPos_1 / hclust_assignments_reduced$Cluster_Sum_mTest_1

hclust_assignments_reduced$Cluster_Med_hhDensity <- with(hclust_assignments_reduced, ave(hhDensity, Hierarch_Clusters, FUN=median))

hclust_assignments_reduced$Cluster_MeanProp_BordersWater <- with(hclust_assignments_reduced, ave(as.numeric(BordersWater) - 1, Hierarch_Clusters, FUN=mean))

hclust_assignments_reduced$Cluster_Sum_BordersWater <- with(hclust_assignments_reduced, ave(as.numeric(BordersWater) - 1, Hierarch_Clusters, FUN=sum))

#Ensuring sorted by clustering
hclust_assignments_reduced <- hclust_assignments_reduced[order(hclust_assignments_reduced$Hierarch_Clusters),]

#Outputting one row per subgroup summary stats
hclust_assignments_reduced <- hclust_assignments_reduced[!duplicated(hclust_assignments_reduced$Hierarch_Clusters),]
```

Weighted CCR for Ward-Like Hierarchical Clustering:

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Weighted CCR
hclust_Weighted_Design_result <- cvrall(clustername = hclust_assignments_reduced$Hierarch_Clusters,
                  balancemetric = "l2",
                  x = data.frame(hclust_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = nrow(hclust_assignments_reduced),
                  ntrt_cluster = nrow(hclust_assignments_reduced)/2,
                  weights = weights,
                  cutoff = 0.1,
                  size = 25000000,
                  seed = 12345)

#Allocation scheme
#hclust_Weighted_Design_result$allocation

# the descriptive statistics for all the variables by the two arms from the selected scheme
#hclust_Weighted_Design_result$baseline_table

#Dataframe with treatment allocations
#hclust_Weighted_Design_result$data_CR

end_time <- Sys.time()
#Saving ccr run time
Weighted_hclust_ccr_time <- end_time - start_time

#Adding the treatment assignments to the dataframe for visualization
hclust_weighted_allocations <- hclust_Weighted_Design_result$allocation
colnames(hclust_weighted_allocations) <- c("Hierarch_Clusters","Weighted_Hierarch_Treatment_Allocation")
study_data_wide <- merge(hclust_weighted_allocations, study_data_wide, by= "Hierarch_Clusters")

#Adding treatment allocations to clusters for proper labeling with spplot()
#Matching rows with SpatialPolygonsDataframe
K_hclust_clustering <- as.data.frame(PKbis_mat)
K_hclust_clustering$id <- 1:nrow(K_hclust_clustering)
#Merging allocations to clusters
hclust_clusters_weighted_ccr_1 <- merge(K_hclust_clustering,hclust_weighted_allocations, by = "Hierarch_Clusters")
hclust_clusters_weighted_ccr_1 <- hclust_clusters_weighted_ccr_1[order(hclust_clusters_weighted_ccr_1$id), ]
#Subsetting village code and clusters
hclust_clusters_weighted_ccr_1 <- hclust_clusters_weighted_ccr_1[,c(4,2)]
rownames(hclust_clusters_weighted_ccr_1) <- hclust_clusters_weighted_ccr_1[,2]#labeling rows

#Balance score for min. scheme
weighted_hclust_ccr_min_score <- as.numeric(hclust_Weighted_Design_result$bscores[5,2])#0.000
#Balance score for selected scheme
weighted_hclust_ccr_selected_score <- as.numeric(hclust_Weighted_Design_result$bscores[1,2])#0.283
#Balance score for cutoff scheme
weighted_hclust_ccr_cutoff_score <- as.numeric(hclust_Weighted_Design_result$bscores[2,2])#0.325
#Balance score for max. scheme
weighted_hclust_ccr_max_score <- as.numeric(hclust_Weighted_Design_result$bscores[14,2])#12.935
```

Unweighted CCR for Ward-Like Hierarchical Clustering:

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Unweighted CCR
hclust_Unweighted_Design_result <- cvrall(clustername = hclust_assignments_reduced$Hierarch_Clusters,
                  balancemetric = "l2",
                  x = data.frame(hclust_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = nrow(hclust_assignments_reduced),
                  ntrt_cluster = nrow(hclust_assignments_reduced)/2,
                  cutoff = 0.1,
                  size = 25000000,
                  seed = 12345)

#Allocation scheme
#hclust_Unweighted_Design_result$allocation

# the descriptive statistics for all the variables by the two arms from the selected scheme
#hclust_Unweighted_Design_result$baseline_table

#Dataframe with treatment allocations
#hclust_Unweighted_Design_result$data_CR

end_time <- Sys.time()

#Saving ccr run time
Unweighted_hclust_ccr_time <- end_time - start_time

#Adding the treatment assignments to the dataframe for visualization
hclust_unweighted_allocations <- hclust_Unweighted_Design_result$allocation
colnames(hclust_unweighted_allocations) <- c("Hierarch_Clusters","Unweighted_Hierarch_Treatment_Allocation")
study_data_wide <- merge(hclust_unweighted_allocations, study_data_wide, by= "Hierarch_Clusters")

#Merging allocations to clusters
hclust_clusters_unweighted_ccr_1 <- merge(K_hclust_clustering,hclust_unweighted_allocations, by = "Hierarch_Clusters")
hclust_clusters_unweighted_ccr_1 <- hclust_clusters_unweighted_ccr_1[order(hclust_clusters_unweighted_ccr_1$id), ]
#Subsetting village code and clusters
hclust_clusters_unweighted_ccr_1 <- hclust_clusters_unweighted_ccr_1[,c(4,2)]
rownames(hclust_clusters_unweighted_ccr_1) <- hclust_clusters_unweighted_ccr_1[,2]#labeling rows

#Balance score for min. scheme
unweighted_hclust_ccr_min_score <- as.numeric(hclust_Unweighted_Design_result$bscores[5,2])#0.000
#Balance score for selected scheme
unweighted_hclust_ccr_selected_score <- as.numeric(hclust_Unweighted_Design_result$bscores[1,2])#1.886
#Balance score for cutoff scheme
unweighted_hclust_ccr_cutoff_score <- as.numeric(hclust_Unweighted_Design_result$bscores[2,2])# 2.866
#Balance score for max. scheme
unweighted_hclust_ccr_max_score <- as.numeric(hclust_Unweighted_Design_result$bscores[14,2])#84.845
```

Comparing the spatial dispersion of treatment arms on nearest neighbor distance (k = 1):

```{r, echo=T, message=F, warning=F}
#Weighted CCR
Weighted_hclust_treatment_0 <- subset(study_data_wide,study_data_wide$Weighted_Hierarch_Treatment_Allocation ==0)
Weighted_hclust_treatment_0 <- cbind(Weighted_hclust_treatment_0$village_long,Weighted_hclust_treatment_0$village_lat)

Weighted_hclust_treatment_1 <- subset(study_data_wide,study_data_wide$Weighted_Hierarch_Treatment_Allocation ==1)
Weighted_hclust_treatment_1 <- cbind(Weighted_hclust_treatment_1$village_long,Weighted_hclust_treatment_1$village_lat)

#Saving CIs for mean nearest-neighbor distance, by treatment allocation
#Treatment 0
Weighted_hclust_treatment_0_nndistCI_k1 <- ci(nndist(Weighted_hclust_treatment_0), confidence = 0.95)
#Treatment 1
Weighted_hclust_treatment_1_nndistCI_k1 <- ci(nndist(Weighted_hclust_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Weighted_hclust_ttest_k1 <- t.test(nndist(Weighted_hclust_treatment_0), nndist(Weighted_hclust_treatment_1))
Weighted_hclust_different_meanNNdists_k1 <- ifelse(Weighted_hclust_ttest_k1$p.value < 0.05, 1, 0)

#Unweighted CCR
Unweighted_hclust_treatment_0 <- subset(study_data_wide,study_data_wide$Unweighted_Hierarch_Treatment_Allocation ==0)
Unweighted_hclust_treatment_0 <- cbind(Unweighted_hclust_treatment_0$village_long,Unweighted_hclust_treatment_0$village_lat)

Unweighted_hclust_treatment_1 <- subset(study_data_wide,study_data_wide$Unweighted_Hierarch_Treatment_Allocation ==1)
Unweighted_hclust_treatment_1 <- cbind(Unweighted_hclust_treatment_1$village_long,Unweighted_hclust_treatment_1$village_lat)

#Saving CIs for mean nearest-neighbor distance, by treatment allocation
#Treatment 0
Unweighted_hclust_treatment_0_nndistCI_k1 <- ci(nndist(Unweighted_hclust_treatment_0), confidence = 0.95)
#Treatment 1
Unweighted_hclust_treatment_1_nndistCI_k1 <- ci(nndist(Unweighted_hclust_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Unweighted_hclust_ttest_k1 <- t.test(nndist(Unweighted_hclust_treatment_0), nndist(Unweighted_hclust_treatment_1))
Unweighted_hclust_different_meanNNdists_k1 <- ifelse(Unweighted_hclust_ttest_k1$p.value < 0.05, 1, 0)
```

#####Determining optimal cluster size using only geographic location

To determine the optimal cluster size using only location, we lock alpha at alpha = 1 (using only Q1). A sensitivity analysis is then conducted to determine the cluster size that maximizes average silhouette width.

```{r, echo=T, message=F, warning=F}
#Getting cluster quality by K
start_time <- Sys.time()#starting timer

clustering_list <- list()#Initializing listing of cluster assignments for each value of K
quality_list <- list()#Initializing listing of cluster value quality for each value of K

#Average Silhouette width (observation).
ASW <- matrix(data = NA, nrow = maxclust-minclust+1, ncol = 1, byrow = FALSE,dimnames = NULL)
row.names(ASW) <- minclust:maxclust

#Performing hierarchical clustering with alpha locked at 1
tree_geo <- hclustgeo(D0_dist,D1_dist,alpha=1)

#Getting average silhouette width
for(i in minclust:maxclust_hclust){
  clustering_list[[i-(minclust-1)]] <- cutree(tree_geo,i)#Making K cuts
  quality_list[[i-(minclust-1)]]  <- wcClusterQuality(D1_dist,clustering_list[[i-(minclust-1)]])
  ASW[i-(minclust-1)] <- quality_list[[i-(minclust-1)]]$stats[4]
} 

#If several values equal to the optimal statistic, then selects the minimum K (first value in array)
ASW_valid <- ASW[seq(1, nrow(ASW), 2),] #Only looking at even K values for CCR (starting from minimum K)
K_ASW <- as.numeric(names(ASW_valid)[which(ASW_valid == max(ASW_valid), arr.ind = TRUE)])[1]

#Using average silhouette width to determine optimal K
K_hclust_geo <- K_ASW

end_time <- Sys.time()

#Saving clustering selection run time
hclust_geo_selection_time <- end_time - start_time

#Performing hierarchical clustering with optimal K
PKbis_geo <- cutree(tree_geo,K_hclust_geo)#Making K cuts

#Extracting clustering scheme
PKbis_geo_mat <- as.matrix(PKbis_geo)
row.names(PKbis_geo_mat) <- names(PKbis_geo)
colnames(PKbis_geo_mat) <- "Hierarch_Geo_Clusters"

#Adding village codes as a variable for linking
hclust_geo_names <- as.matrix(rownames(PKbis_geo_mat))
colnames(hclust_geo_names) <- "village_code"
PKbis_geo_mat <- as.matrix(cbind(PKbis_geo_mat,hclust_geo_names))

#Merging back hclust scheme
study_data_wide <- merge(PKbis_geo_mat, study_data_wide, by="village_code")

#Failsafe resetting row names
row.names(study_data_wide) <- study_data_wide$village_code

#Plotting
sp::plot(map,border="grey",col=PKbis_geo, main= "Ward-Like Hierarchical Clustering of Size 12 Obtained with only Geographic Location \n (alpha = 1)",cex.main=1)
legend("topleft", legend=paste("Cluster",1:max(PKbis_geo)), fill=1:max(PKbis_geo), bty="n",border="grey")
text(coordinates(map), labels = PKbis)

#Black and white
#plot(map, main="Ward-Like Hierarchical Clustering of Size 12 Obtained with only Geographic Location (alpha = 1)",cex.main=2.2)
#text(coordinates(map), labels = PKbis_geo, cex = 2)
```

#####CCR for Ward-like Hierarchical Clustering

```{r, echo=T, message=F, warning=F}
#Getting cluster-level statistics for hierarchical clustering scheme
hclust_geo_assignments_reduced <- study_data_wide[,c("Hierarch_Geo_Clusters","microPos_5","microPos_1", "microTests_5","microTests_1", "BordersWater", "hhDensity")]

hclust_geo_assignments_reduced$Cluster_Sum_mPos_5 <- with(hclust_geo_assignments_reduced, ave(microPos_5, Hierarch_Geo_Clusters, FUN=sum))

hclust_geo_assignments_reduced$Cluster_Sum_mPos_1 <- with(hclust_geo_assignments_reduced, ave(microPos_1, Hierarch_Geo_Clusters, FUN=sum))

hclust_geo_assignments_reduced$Cluster_Sum_mTest_5 <- with(hclust_geo_assignments_reduced, ave(microTests_5, Hierarch_Geo_Clusters, FUN=sum))

hclust_geo_assignments_reduced$Cluster_Sum_mTest_1 <- with(hclust_geo_assignments_reduced, ave(microTests_1, Hierarch_Geo_Clusters, FUN=sum))

hclust_geo_assignments_reduced$Cluster_mRate_5 <- hclust_geo_assignments_reduced$Cluster_Sum_mPos_5 / hclust_geo_assignments_reduced$Cluster_Sum_mTest_5

hclust_geo_assignments_reduced$Cluster_mRate_1 <- hclust_geo_assignments_reduced$Cluster_Sum_mPos_1 / hclust_geo_assignments_reduced$Cluster_Sum_mTest_1

hclust_geo_assignments_reduced$Cluster_Med_hhDensity <- with(hclust_geo_assignments_reduced, ave(hhDensity, Hierarch_Geo_Clusters, FUN=median))

hclust_geo_assignments_reduced$Cluster_MeanProp_BordersWater <- with(hclust_geo_assignments_reduced, ave(as.numeric(BordersWater) - 1, Hierarch_Geo_Clusters, FUN=mean))

hclust_geo_assignments_reduced$Cluster_Sum_BordersWater <- with(hclust_geo_assignments_reduced, ave(as.numeric(BordersWater) - 1, Hierarch_Geo_Clusters, FUN=sum))

#ensuring sorted by clustering
hclust_geo_assignments_reduced <- hclust_geo_assignments_reduced[order(hclust_geo_assignments_reduced$Hierarch_Geo_Clusters),]

#outputting one row per subgroup summary stats
hclust_geo_assignments_reduced <- hclust_geo_assignments_reduced[!duplicated(hclust_geo_assignments_reduced$Hierarch_Geo_Clusters),]
```

Weighted CCR for Ward-Like Hierarchical Clustering (Euclidean Distance Only):

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Weighted CCR
hclust_geo_Weighted_Design_result <- cvrall(clustername = hclust_geo_assignments_reduced$Hierarch_Geo_Clusters,
                  balancemetric = "l2",
                  x = data.frame(hclust_geo_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = nrow(hclust_geo_assignments_reduced),
                  ntrt_cluster = nrow(hclust_geo_assignments_reduced)/2,
                  weights = weights,
                  cutoff = 0.1,
                  size = 25000000,
                  seed = 12345)

#Allocation scheme
#hclust_geo_Weighted_Design_result$allocation

# the descriptive statistics for all the variables by the two arms from the selected scheme
#hclust_geo_Weighted_Design_result$baseline_table

#Dataframe with treatment allocations
#hclust_geo_Weighted_Design_result$data_CR

end_time <- Sys.time()
#Saving ccr run time
Weighted_hclust_geo_ccr_time <- end_time - start_time

#Adding the treatment assignments to the dataframe for visualization
hclust_geo_weighted_allocations <- hclust_geo_Weighted_Design_result$allocation
colnames(hclust_geo_weighted_allocations) <- c("Hierarch_Geo_Clusters","Weighted_Hierarch_Geo_Treatment_Allocation")
study_data_wide <- merge(hclust_geo_weighted_allocations, study_data_wide, by= "Hierarch_Geo_Clusters")

#Adding treatment allocations to clusters for proper labeling with spplot()
#Matching rows with SpatialPolygonsDataframe
K_hclust_geo_clustering <- as.data.frame(PKbis_geo_mat)
K_hclust_geo_clustering$id <- 1:nrow(K_hclust_geo_clustering)
#Merging allocations to clusters
hclust_geo_clusters_weighted_ccr_1 <- merge(K_hclust_geo_clustering,hclust_geo_weighted_allocations, by = "Hierarch_Geo_Clusters")
hclust_geo_clusters_weighted_ccr_1 <- hclust_geo_clusters_weighted_ccr_1[order(hclust_geo_clusters_weighted_ccr_1$id), ]
#Subsetting village code and clusters
hclust_geo_clusters_weighted_ccr_1 <- hclust_geo_clusters_weighted_ccr_1[,c(4,2)]
rownames(hclust_geo_clusters_weighted_ccr_1) <- hclust_geo_clusters_weighted_ccr_1[,2]#labeling rows

#Balance score for min. scheme
weighted_hclust_geo_ccr_min_score <- as.numeric(hclust_geo_Weighted_Design_result$bscores[5,2])#0.02
#Balance score for selected scheme
weighted_hclust_geo_ccr_selected_score <- as.numeric(hclust_geo_Weighted_Design_result$bscores[1,2])#0.152
#Balance score for cutoff scheme
weighted_hclust_geo_ccr_cutoff_score <- as.numeric(hclust_geo_Weighted_Design_result$bscores[2,2])#0.185
#Balance score for max. scheme
weighted_hclust_geo_ccr_max_score <- as.numeric(hclust_geo_Weighted_Design_result$bscores[14,2])#5.814
```

Unweighted CCR for Ward-Like Hierarchical Clustering (Euclidean Distance Only):

```{r, echo=T, message=F, warning=F}
start_time <- Sys.time()

#Unweighted CCR
hclust_geo_Unweighted_Design_result <- cvrall(clustername = hclust_geo_assignments_reduced$Hierarch_Geo_Clusters,
                  balancemetric = "l2",
                  x = data.frame(hclust_geo_assignments_reduced[ , c("Cluster_mRate_1", "Cluster_Med_hhDensity", "Cluster_MeanProp_BordersWater")]),
                  ntotal_cluster = nrow(hclust_geo_assignments_reduced),
                  ntrt_cluster = nrow(hclust_geo_assignments_reduced)/2,
                  cutoff = 0.1,
                  size = 25000000,
                  seed = 12345)

#Allocation scheme
#hclust_geo_Unweighted_Design_result$allocation

# the descriptive statistics for all the variables by the two arms from the selected scheme
#hclust_geo_Unweighted_Design_result$baseline_table

#Dataframe with treatment allocations
#hclust_geo_Unweighted_Design_result$data_CR

end_time <- Sys.time()

#Saving ccr run time
Unweighted_hclust_geo_ccr_time <- end_time - start_time

#Adding the treatment assignments to the dataframe for visualization
hclust_geo_unweighted_allocations <- hclust_geo_Unweighted_Design_result$allocation
colnames(hclust_geo_unweighted_allocations) <- c("Hierarch_Geo_Clusters","Unweighted_Hierarch_Geo_Treatment_Allocation")
study_data_wide <- merge(hclust_geo_unweighted_allocations, study_data_wide, by= "Hierarch_Geo_Clusters")

#Merging allocations to clusters
hclust_geo_clusters_unweighted_ccr_1 <- merge(K_hclust_geo_clustering,hclust_geo_unweighted_allocations, by = "Hierarch_Geo_Clusters")
hclust_geo_clusters_unweighted_ccr_1 <- hclust_geo_clusters_unweighted_ccr_1[order(hclust_geo_clusters_unweighted_ccr_1$id), ]
#Subsetting village code and clusters
hclust_geo_clusters_unweighted_ccr_1 <- hclust_geo_clusters_unweighted_ccr_1[,c(4,2)]
rownames(hclust_geo_clusters_unweighted_ccr_1) <- hclust_geo_clusters_unweighted_ccr_1[,2]#labeling rows

#Balance score for min. scheme
unweighted_hclust_geo_ccr_min_score <- as.numeric(hclust_geo_Unweighted_Design_result$bscores[5,2])#0.242
#Balance score for selected scheme
unweighted_hclust_geo_ccr_selected_score <- as.numeric(hclust_geo_Unweighted_Design_result$bscores[1,2])#1.632
#Balance score for cutoff scheme
unweighted_hclust_geo_ccr_cutoff_score <- as.numeric(hclust_geo_Unweighted_Design_result$bscores[2,2])#2.002
#Balance score for max. scheme
unweighted_hclust_geo_ccr_max_score <- as.numeric(hclust_geo_Unweighted_Design_result$bscores[14,2])#31.655
```

Comparing the spatial dispersion of treatment arms on nearest neighbor distance (k = 1):

```{r, echo=T, message=F, warning=F}
#Weighted CCR
Weighted_hclust_geo_treatment_0 <- subset(study_data_wide,study_data_wide$Weighted_Hierarch_Geo_Treatment_Allocation ==0)
Weighted_hclust_geo_treatment_0 <- cbind(Weighted_hclust_geo_treatment_0$village_long,Weighted_hclust_geo_treatment_0$village_lat)

Weighted_hclust_geo_treatment_1 <- subset(study_data_wide,study_data_wide$Weighted_Hierarch_Geo_Treatment_Allocation ==1)
Weighted_hclust_geo_treatment_1 <- cbind(Weighted_hclust_geo_treatment_1$village_long,Weighted_hclust_geo_treatment_1$village_lat)

#Saving CIs for mean nearest-neighbor distance, by treatment allocation
#Treatment 0
Weighted_hclust_geo_treatment_0_nndistCI_k1 <- ci(nndist(Weighted_hclust_geo_treatment_0), confidence = 0.95)
#Treatment 1
Weighted_hclust_geo_treatment_1_nndistCI_k1 <- ci(nndist(Weighted_hclust_geo_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Weighted_hclust_geo_ttest_k1 <- t.test(nndist(Weighted_hclust_geo_treatment_0), nndist(Weighted_hclust_geo_treatment_1))
Weighted_hclust_geo_different_meanNNdists_k1 <- ifelse(Weighted_hclust_geo_ttest_k1$p.value < 0.05, 1, 0)

#Unweighted CCR
Unweighted_hclust_geo_treatment_0 <- subset(study_data_wide,study_data_wide$Unweighted_Hierarch_Geo_Treatment_Allocation ==0)
Unweighted_hclust_geo_treatment_0 <- cbind(Unweighted_hclust_geo_treatment_0$village_long,Unweighted_hclust_geo_treatment_0$village_lat)

Unweighted_hclust_geo_treatment_1 <- subset(study_data_wide,study_data_wide$Unweighted_Hierarch_Geo_Treatment_Allocation ==1)
Unweighted_hclust_geo_treatment_1 <- cbind(Unweighted_hclust_geo_treatment_1$village_long,Unweighted_hclust_geo_treatment_1$village_lat)

#Saving CIs for mean nearest-neighbor distance, by treatment allocation
#Treatment 0
Unweighted_hclust_geo_treatment_0_nndistCI_k1 <- ci(nndist(Unweighted_hclust_geo_treatment_0), confidence = 0.95)
#Treatment 1
Unweighted_hclust_geo_treatment_1_nndistCI_k1 <- ci(nndist(Unweighted_hclust_geo_treatment_1), confidence = 0.95)

#Testing for significant differences in mean nn-dist with Welch Two Sample t-test
Unweighted_hclust_geo_ttest_k1 <- t.test(nndist(Unweighted_hclust_geo_treatment_0), nndist(Unweighted_hclust_geo_treatment_1))
Unweighted_hclust_geo_different_meanNNdists_k1 <- ifelse(Unweighted_hclust_geo_ttest_k1$p.value < 0.05, 1, 0)
```


###Results

####CCR Scores

```{r, echo=F, message=F, warning=F}
#kmeans
k_means_ccr_scores <- cbind(c(weighted_kmeans_ccr_min_score,unweighted_kmeans_ccr_min_score), c(weighted_kmeans_ccr_selected_score,unweighted_kmeans_ccr_selected_score), c(weighted_kmeans_ccr_cutoff_score, unweighted_kmeans_ccr_cutoff_score), c(weighted_kmeans_ccr_max_score,unweighted_kmeans_ccr_max_score), c(K_kmeans/2, K_kmeans/2), c(kmeans_Weighted_Design_result$overall_allocations[3], kmeans_Unweighted_Design_result$overall_allocations[3]))
rownames(k_means_ccr_scores) <- c("K-Means Weighted", "K-Means Unweighted")
colnames(k_means_ccr_scores) <- c("Minimum Score", "Selected Balance Score", "10% Cutoff Score", "Maximum Score", "Number of Clusters in Each Treatment Arm", "Number of Allocations in Randomization Space")

#clara
clara_ccr_scores <- cbind(c(weighted_clara_ccr_min_score,unweighted_clara_ccr_min_score), c(weighted_clara_ccr_selected_score,unweighted_clara_ccr_selected_score), c(weighted_clara_ccr_cutoff_score, unweighted_clara_ccr_cutoff_score), c(weighted_clara_ccr_max_score,unweighted_clara_ccr_max_score), c(K_clara/2, K_clara/2), c(CLARA_Weighted_Design_result$overall_allocations[3], CLARA_Unweighted_Design_result$overall_allocations[3]))
rownames(clara_ccr_scores) <- c("CLARA Weighted", "CLARA Unweighted")
colnames(clara_ccr_scores) <- c("Minimum Score", "Selected Balance Score", "10% Cutoff Score", "Maximum Score", "Number of Clusters in Each Treatment Arm", "Number of Allocations in Randomization Space")

#hclust - geo only
hclust_geo_ccr_scores <- cbind(c(weighted_hclust_geo_ccr_min_score,unweighted_hclust_geo_ccr_min_score), c(weighted_hclust_geo_ccr_selected_score,unweighted_hclust_geo_ccr_selected_score), c(weighted_hclust_geo_ccr_cutoff_score, unweighted_hclust_geo_ccr_cutoff_score), c(weighted_hclust_geo_ccr_max_score,unweighted_hclust_geo_ccr_max_score), c(K_hclust_geo/2, K_hclust_geo/2), c(hclust_geo_Weighted_Design_result$overall_allocations[3], hclust_geo_Unweighted_Design_result$overall_allocations[3]))
rownames(hclust_geo_ccr_scores) <- c("H-Clust Weighted - Geo. Only", "H-Clust Unweighted - Geo. Only")
colnames(hclust_geo_ccr_scores) <- c("Minimum Score", "Selected Balance Score", "10% Cutoff Score", "Maximum Score", "Number of Clusters in Each Treatment Arm", "Number of Allocations in Randomization Space")

#hclust
hclust_ccr_scores <- cbind(c(weighted_hclust_ccr_min_score,unweighted_hclust_ccr_min_score), c(weighted_hclust_ccr_selected_score,unweighted_hclust_ccr_selected_score), c(weighted_hclust_ccr_cutoff_score, unweighted_hclust_ccr_cutoff_score), c(weighted_hclust_ccr_max_score,unweighted_hclust_ccr_max_score), c(K_hclust/2, K_hclust/2), c(hclust_Weighted_Design_result$overall_allocations[3], hclust_Unweighted_Design_result$overall_allocations[3]))
rownames(hclust_ccr_scores) <- c("H-Clust Weighted", "H-Clust Unweighted")
colnames(hclust_ccr_scores) <- c("Minimum Score", "Selected Balance Score", "10% Cutoff Score", "Maximum Score", "Number of Clusters in Each Treatment Arm", "Number of Allocations in Randomization Space")

#Combining
rbind(k_means_ccr_scores, clara_ccr_scores, hclust_geo_ccr_scores, hclust_ccr_scores)
```

In terms of selected balance score, the top four performers were: CLARA with weighted CCR (0.093); Ward-like hierarchical clustering with weighted CCR, using geographic location (0.152); K-Means with weighted CCR (0.263); Ward-like hierarchical clustering with weighted CCR, using geographic location and covariate dissimilarity (0.283). In terms of the maximum (10%) cutoff score, the top four performers were: CLARA with weighted CCR (0.112); Ward-like hierarchical clustering with weighted CCR, using geographic location (0.185); K-Means with weighted CCR (0.299); Ward-like hierarchical clustering with weighted CCR, using geographic location and covariate dissimilarity (0.325).

###CCR Treatment Arm Contiguity (Measured with Mean Nearest Neighbor Distance)

####Study 1

```{r, echo=F, message=F, warning=F}
#Weighted
#kmeans
weighted_kmeans_nndistCIs_k1 <- rbind(Weighted_kmeans_treatment_0_nndistCI_k1, Weighted_kmeans_treatment_1_nndistCI_k1)
rownames(weighted_kmeans_nndistCIs_k1) <- c("K-means with Weighted CCR: Treatment 0", "K-means with Weighted CCR: Treatment 1")
colnames(weighted_kmeans_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

weighted_kmeans_different_meanNNdists_k1 <- as.matrix(Weighted_kmeans_different_meanNNdists_k1)
rownames(weighted_kmeans_different_meanNNdists_k1) <- "Weighted K-Means"
colnames(weighted_kmeans_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"

#clara
weighted_clara_nndistCIs_k1 <- rbind(Weighted_clara_treatment_0_nndistCI_k1, Weighted_clara_treatment_1_nndistCI_k1)
rownames(weighted_clara_nndistCIs_k1) <- c("CLARA with Weighted CCR: Treatment 0", "CLARA with Weighted CCR: Treatment 1")
colnames(weighted_clara_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

weighted_clara_different_meanNNdists_k1 <- as.matrix(Weighted_clara_different_meanNNdists_k1)
rownames(weighted_clara_different_meanNNdists_k1) <- "Weighted CLARA"
colnames(weighted_clara_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"

#hclust - geo. only
weighted_hclust_geo_nndistCIs_k1 <- rbind(Weighted_hclust_geo_treatment_0_nndistCI_k1, Weighted_hclust_geo_treatment_1_nndistCI_k1)
rownames(weighted_hclust_geo_nndistCIs_k1) <- c("Hierarchical with Weighted CCR - Geo. Only: Treatment 0", "Hierarchical with Weighted CCR - Geo. Only: Treatment 1")
colnames(weighted_hclust_geo_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

weighted_hclust_geo_different_meanNNdists_k1 <- as.matrix(Weighted_hclust_geo_different_meanNNdists_k1)
rownames(weighted_hclust_geo_different_meanNNdists_k1) <- "Weighted Hierarchical - Geo. Only"
colnames(weighted_hclust_geo_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"

#hclust
weighted_hclust_nndistCIs_k1 <- rbind(Weighted_hclust_treatment_0_nndistCI_k1, Weighted_hclust_treatment_1_nndistCI_k1)
rownames(weighted_hclust_nndistCIs_k1) <- c("Hierarchical with Weighted CCR: Treatment 0", "Hierarchical with Weighted CCR: Treatment 1")
colnames(weighted_hclust_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

weighted_hclust_different_meanNNdists_k1 <- as.matrix(Weighted_hclust_different_meanNNdists_k1)
rownames(weighted_hclust_different_meanNNdists_k1) <- "Weighted Hierarchical"
colnames(weighted_hclust_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"


#Unweighted
#kmeans
unweighted_kmeans_nndistCIs_k1 <- rbind(Unweighted_kmeans_treatment_0_nndistCI_k1, Unweighted_kmeans_treatment_1_nndistCI_k1)
rownames(unweighted_kmeans_nndistCIs_k1) <- c("K-means with Unweighted CCR: Treatment 0", "K-means with Unweighted CCR: Treatment 1")
colnames(unweighted_kmeans_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

unweighted_kmeans_different_meanNNdists_k1 <- as.matrix(Unweighted_kmeans_different_meanNNdists_k1)
row.names(unweighted_kmeans_different_meanNNdists_k1) <- "Unweighted K-Means"
colnames(unweighted_kmeans_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"

#clara
unweighted_clara_nndistCIs_k1 <- rbind(Unweighted_clara_treatment_0_nndistCI_k1, Unweighted_clara_treatment_1_nndistCI_k1)
rownames(unweighted_clara_nndistCIs_k1) <- c("CLARA with Unweighted CCR: Treatment 0", "CLARA with Unweighted CCR: Treatment 1")
colnames(unweighted_clara_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

unweighted_clara_different_meanNNdists_k1 <- as.matrix(Unweighted_clara_different_meanNNdists_k1)
row.names(unweighted_clara_different_meanNNdists_k1) <- "Unweighted CLARA"
colnames(unweighted_clara_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"

#hclust euclidean
unweighted_hclust_geo_nndistCIs_k1 <- rbind(Unweighted_hclust_geo_treatment_0_nndistCI_k1, Unweighted_hclust_geo_treatment_1_nndistCI_k1)
rownames(unweighted_hclust_geo_nndistCIs_k1) <- c("Hierarchical with Unweighted CCR: Treatment 0", "Hierarchical with Unweighted CCR: Treatment 1")
colnames(unweighted_hclust_geo_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

unweighted_hclust_geo_different_meanNNdists_k1 <- as.matrix(Unweighted_hclust_geo_different_meanNNdists_k1)
row.names(unweighted_hclust_geo_different_meanNNdists_k1) <- "Unweighted Hierarchical - Geo. Only"
colnames(unweighted_hclust_geo_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"

#hclust both
unweighted_hclust_nndistCIs_k1 <- rbind(Unweighted_hclust_treatment_0_nndistCI_k1, Unweighted_hclust_treatment_1_nndistCI_k1)
rownames(unweighted_hclust_nndistCIs_k1) <- c("Hierarchical with Unweighted CCR: Treatment 0", "Hierarchical with Unweighted CCR: Treatment 1")
colnames(unweighted_hclust_nndistCIs_k1) <- c("Mean Nearest Neighbor Distance (k = 1)", "CI lower", "CI upper", "Std. Error")

unweighted_hclust_different_meanNNdists_k1 <- as.matrix(Unweighted_hclust_different_meanNNdists_k1)
row.names(unweighted_hclust_different_meanNNdists_k1) <- "Unweighted Hierarchical"
colnames(unweighted_hclust_different_meanNNdists_k1) <- "Difference in cluster spatial variability (k = 1)? (0 = No, 1 = Yes)"


#Combining for display
rbind(weighted_kmeans_nndistCIs_k1, unweighted_kmeans_nndistCIs_k1, weighted_clara_nndistCIs_k1, unweighted_clara_nndistCIs_k1, weighted_hclust_geo_nndistCIs_k1, unweighted_hclust_geo_nndistCIs_k1,
      weighted_hclust_nndistCIs_k1, unweighted_hclust_nndistCIs_k1)

rbind(weighted_kmeans_different_meanNNdists_k1, unweighted_kmeans_different_meanNNdists_k1,
      weighted_clara_different_meanNNdists_k1, unweighted_clara_different_meanNNdists_k1,
      weighted_hclust_geo_different_meanNNdists_k1, unweighted_hclust_geo_different_meanNNdists_k1,
      weighted_hclust_different_meanNNdists_k1, unweighted_hclust_different_meanNNdists_k1)

```

At significance level alpha = 0.05, the CCR allocations that resulted in significantly different mean nearest neighbor distances between treatment arms were: K-Means with weighted and unweighted CCR; CLARA with unweighted CCR; Ward-like hierarchical (using Geographic location only) with weighted and unweighted CCR.

### CPU Run Times

```{r, echo=F, message=F, warning=F}
#kmeans
kmeans_runtimes <- c(K_means_selection_time,  Weighted_K_means_ccr_time, Unweighted_K_means_ccr_time)
kmeans_runtimes <- as.matrix(kmeans_runtimes)
rownames(kmeans_runtimes) <- c("Optimizing Clusters", "Weighted CCR", "Unweighted CCR")
colnames(kmeans_runtimes) <- "K-Means Time (seconds)"

#clara
clara_runtimes <- c(clara_selection_time, Weighted_clara_ccr_time, Unweighted_clara_ccr_time)
clara_runtimes <- as.matrix(clara_runtimes)
rownames(clara_runtimes) <- c("Optimizing Clusters",  "Weighted CCR", "Unweighted CCR")
colnames(clara_runtimes) <- "CLARA Time (seconds)"

#hclust euclidean
hclust_geo_runtimes <- c(hclust_geo_selection_time, Weighted_hclust_geo_ccr_time, Unweighted_hclust_geo_ccr_time)
hclust_geo_runtimes <- as.matrix(hclust_geo_runtimes)
rownames(hclust_geo_runtimes) <- c("Optimizing Clusters", "Weighted CCR", "Unweighted CCR")
colnames(hclust_geo_runtimes) <- "H-Clust Geo. Time (seconds)"

#hclust both
hclust_runtimes <- c(hclust_selection_time, Weighted_hclust_ccr_time, Unweighted_hclust_ccr_time)
hclust_runtimes <- as.matrix(hclust_runtimes)
rownames(hclust_runtimes) <- c("Optimizing Clusters", "Weighted CCR", "Unweighted CCR")
colnames(hclust_runtimes) <- "H-Clust Time Euc. Geo./Gower Cov. (seconds)"

#Combining for display
cbind(kmeans_runtimes,clara_runtimes, hclust_geo_runtimes, hclust_runtimes)
```

In terms of CPU run times, Ward-like hierarchical clustering with mixed dissimilarities took the longest to run, due to its cluster optimization phase, though by only a few extra seconds. All three geographic location-only methods appear to have no clear differences between them, and are somewhat comparable to one another.


###Visualization of Treatment Allocations

####K-Means

```{r, echo=F, message=F, warning=F}
#Visualizing clusters
sp::plot(map,border="grey",col=K_kmeans_clustering[,1], main= "12-Cluster Partition Obtained with K-Means on Centroid Euclidean Distance",cex.main=1)
legend("left", legend=paste("Cluster",1:K_kmeans), fill=1:K_kmeans, bty="n",border="grey")

#Weighted CCR
sp::plot(map,border="grey",col= Kmeans_clusters_weighted_ccr_1[,1], main= "Treatment Allocations Obtained with K-Means and Weighted CCR",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")

#Unweighted CCR
sp::plot(map,border="grey",col=Kmeans_clusters_unweighted_ccr_1[,1], main= "Treatment Allocations Obtained with K-Means and Unweighted CCR",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")
```

####CLARA

```{r, echo=F, message=F, warning=F}
#Visualizing clusters
sp::plot(map,border="grey",col=K_clara_clustering[,1], main= "8-Cluster Partition Obtained with CLARA on Centroid Euclidean Distance",cex.main=1)
legend("bottomleft", legend=paste("Cluster",1:K_clara), fill=1:K_clara, bty="n",border="grey")

#Weighted CCR
sp::plot(map,border="grey",col=clara_clusters_weighted_ccr_1[,1], main= "Treatment allocations Obtained with CLARA Clustering, Weighted CCR",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")

#Unweighted CCR
sp::plot(map,border="grey",col=clara_clusters_unweighted_ccr_1[,1], main= "Treatment allocations Obtained with CLARA Clustering, Unweighted CCR",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")
```

####Ward-Like Hierarchical Clustering with Euclidean Distance

```{r, echo=F, message=F, warning=F}
#Plotting clusters
sp::plot(map,border="grey",col=PKbis_geo, main= "Ward-Like Hierarchical Clustering of Size 12 Obtained with Geographic Location \n (alpha=1)",cex.main=1)
legend("topleft", legend=paste("Cluster",1:max(PKbis_geo)), fill=1:max(PKbis_geo), bty="n",border="grey")
#Weighted CCR
sp::plot(map,border="grey",col=hclust_geo_clusters_weighted_ccr_1[,1], main= "Treatment Allocations Obtained with \n Ward-Like Hierarchical Clustering, Weighted CCR - Geographic Location Only",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")
#Unweighted CCR
sp::plot(map,border="grey",col=hclust_geo_clusters_unweighted_ccr_1[,1], main= "Treatment Allocations Obtained with \n Ward-Like Hierarchical Clustering, Unweighted CCR - Geographic Location Only",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")
```

####Ward-Like Hierarchical Clustering with Euclidean Distance and Mixed Covariate Dissimilarity

```{r, echo=F, message=F, warning=F}
#Plotting clusters
sp::plot(map,border="grey",col=PKbis, main= "Ward-Like Hierarchical Clustering of Size 18 Obtained with alpha=0.6",cex.main=1)
legend("topleft", legend=paste("Cluster",1:max(PKbis)), fill=1:max(PKbis), bty="n",border="grey", cex = .8)
#Weighted CCR
sp::plot(map,border="grey",col=hclust_clusters_weighted_ccr_1[,1], main= "Treatment Allocations Obtained with \n Ward-Like Hierarchical Clustering, Weighted CCR",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")
#Unweighted CCR
sp::plot(map,border="grey",col=hclust_clusters_unweighted_ccr_1[,1], main= "Treatment Allocations Obtained with \n Ward-Like Hierarchical Clustering, Unweighted CCR",cex.main=1)
legend("bottomleft", legend=paste("Treatment",1:2), fill=0:1, bty="n",border="grey")
```

###Conclusions

Strategic weighting of covariates during CCR, regardless of clustering method, served to drastically improve covariate balance during randomization into CRT treatment arms. In terms of minimizing covariate imbalance, Ward-like hierarchical using only geographic location (Euclidean distance) and weighting during CCR appears to perform better than the more complicated, and more computationally-intensive, mixed-dissimilarity method. For CRT design using Ward-like hierarchical clustering with weighted CCR, this added level of sophistication may be unnecessary. Clustering on geographic location - with weighting during CCR - may sufficiently balance treatment arms with respect to important spatial feature data.

Based on 10% cutoff balance scores and CPU run times, either CLARA with weighted CCR or Ward-Like Hierarchical Clustering with Euclidean geographical dissimilarities and weighted CCR may be considered optimal study design strategies. Ward-Like Hierarchical Clustering with Euclidean geographical dissimilarities and weighted CCR maintained spatial heterogeneity of treatment assignments. Thus, for this data scenario, Ward-Like Hierarchical Clustering with Euclidean geographical dissimilarities and weighted CCR performed optimally (i.e., optimized covariate balance while maintaining spatial heterogeneity of treatment assignments).

In this paper, we presented a stepwise methodological approach to mitigating covariate imbalance and intervention contamination in a CRT. Future enhancements to this approach might include optimization of covariate imbalance and spatial clustering of intervention arms simultaneously.

###Limitations

For simplicity, the only cluster quality statistic used to optimize clustering methods was average silhouette width. It may be of interest to examine additional, potential cluster quality statistics that are applicable for clustering on a variety of data types (e.g., numerical, nominal, ordinal). Furthermore, "ClustGeo" limits the maximum number of clusters to 55; this may be impractical for some large CRT studies. For large CRTs, K-Means or CLARA with weighted CCR may be preferable to Ward-Like hierarchical clustering.

Clustering and treatment assignments, as well as conclusions on spatial heterogeneity of treatment assignments, may be influenced by geographical barriers between units (e.g., mountains, canyons, swamps). These barriers may prevent spatial contamination of subjects across units, but they were not considered in the applications presented here.

Unlike the spatial clustering methods outlined here, density-based spatial clustering methods (e.g., DBSCAN) can detect clusters of arbitrary shape [12]. As the geographic region for this and many studies is oblong, and not uniformly- distributed, such an algorithm may be of use for assigning units to CRT treatment arms. Unfortunately, as it is not a hard clustering algorithm and may result in some units belonging to multiple or no clusters, density-based clustering was not considered in this example.

###References

1. Moulton, L. (2004). Covariate-based constrained randomization of group-randomized trials. Clinical Trials. 1: 297-305.

2. Pebesma, E.J., R.S. Bivand. (2005). Classes and methods for spatial data in R. R News 5 (2), https://cran.r-project.org/doc/Rnews/.

3.  Roger S. Bivand, Edzer Pebesma, Virgilio Gomez-Rubio. (2013). Applied spatial data analysis with R, Second edition. Springer, NY. http://www.asdar-book.org/.

4.  H. Wickham. (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York.

5. Studer, Matthias (2013). WeightedCluster Library Manual: A practical guide to creating typologies of trajectories in the social sciences with R. LIVES Working Papers, 24. DOI: 10.12682/lives.2296-1658.2013.24.

6. Marie Chavent, Vanessa Kuentz, Amaury Labenne and Jerome Saracco (2017). ClustGeo: Hierarchical Clustering with Spatial Constraints. R package version 2.0. https://CRAN.R-project.org/package=ClustGeo.

7. Maechler, M. Cluster. Retrived from https://www.rdocumentation.org/packages/cluster/versions/2.0.7-1/topics/daisy.

8. Hengshi Yu, Fan Li, John A. Gallis and Elizabeth L. Turner (2019). cvcrand: Efficient Design and Analysis of Cluster Randomized Trials. R package version 0.0.3. https://CRAN.R-project.org/package=cvcrand.

9. Adrian Baddeley, Ege Rubak, Rolf Turner (2015). Spatial Point Patterns: Methodology and Applications with R. London: Chapman and Hall/CRC Press, 2015. http://www.crcpress.com/Spatial-Point-Patterns-Methodology-and-Applications-with-R/Baddeley-Rubak-Turner/9781482210200/.

10. Maechler, M. Cluster. Retrieved from https://www.rdocumentation.org/packages/cluster/versions/2.0.7-1/topics/clara.

11. Gower J. C. (1971). A general coefficient of similarity and some of its properties. Biometrics. 27, 857-872.

12. Ram A, Jalal S, Jalal AS, Kumar M. (2010). A Density Based Algorithm for Discovering Density Varied Clusters in Large Spatial Databases. International Journal of Computer Applications. 3(6):1-4.
